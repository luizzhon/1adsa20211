CREATE DATABASE faculdade;
USE faculdade;

CREATE TABLE Empresa (
IDEmpresa int primary key auto_increment,
    nomeEmpresa varchar(50),
    responsavel varchar(50)
);

INSERT INTO Empresa values
(null, 'Fleury', 'Maria'),
(null, 'C6', 'Pedro'),
(null, 'TIVIT', 'Camila'),
(null, 'Safra', 'Natalia');

SELECT * FROM Empresa;

SELECT nomeEmpresa, responsavel FROM Empresa;

SELECT * FROM Empresa order by nomeEmpresa;

SELECT * FROM Empresa order by responsavel desc;

SELECT * FROM Empresa WHERE nomeEmpresa LIKE '%r%';

SELECT * FROM Empresa WHERE nomeEmpresa LIKE 'f%';

SELECT * FROM Empresa WHERE nomeEmpresa LIKE '%r_';

INSERT INTO Empresa VALUES (null,'C6','Paulo');

DELETE FROM Empresa where idEmpresa =3;

DROP TABLE Empresa;

INSERT INTO Empresa VALUES (null,'Bandtec','Vera');

ALTER TABLE Empresa MODIFY nomeEmpresa varchar(40);

ALTER TABLE NomeDaTabela MODIFY NomeDoCampo TipoDoCampo;

Exemplo: ALTER TABLE empresa MODIFY NomeEmpresa VARCHAR(50);

COMANDOS PARA CRIAR USU√ÅRIO E REALIZAR LOGIN MySQL Server CLI:

-- Entrar no prompt de comando/cmd
-- win + r, digitar cmd, pressionar ok

-- Entrar no diret√≥rio bin do MySQL Server: arquivo mysql.exe
-- cd C:\Program Files\MySQL\MySQL Server 8.0\bin

-- Entrar no MySQL Server com o usu√°rio root
-- mysql -u root -p

-- Digitar a senha do usu√°rio root

-- Criar usu√°rio MySQL Server via linha de comando
CREATE USER 'consultor'@'localhost' IDENTIFIED BY 'urubu100';

-- Dar todas as permiss√µes ao usu√°rio criado
GRANT ALL ON *.* TO 'consultor'@'localhost';

-- Dar permiss√£o de apenas consulta
GRANT SELECT, UPDATE ON *.* TO 'consultor'@'localhost';

-- Confirmar as permiss√µes/privil√©gios
flush privileges;




SCRIPT TABELA AULA:

USE faculdade;

CREATE TABLE aula (
	idAula int primary key auto_increment,
    nomeAula varchar(75),
    tipo char(1),
    check (tipo = 'o' or tipo = 'h' or tipo = 'p'),
    dtAula date,
    mensagem varchar(100)
);

INSERT INTO aula values 
	(null, 'Apresenta√ß√£o da disciplina e primeiros conceitos',
		'o', '2021-02-04', 'Conhecendo Banco de Dados'),
    (null, 'Continua√ß√£o de conceitos e primeiros comandos SQL',
		'o', '2021-02-11', 'O primeiro comando a gente nunca esquece');
    
SELECT * FROM aula;

INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Permiss√£o de usu√°rio e comandos gerais', 'p', 
    '2021-02-18', 'Sejam bem vindos!');




SCRIPT TABELA ALUNO ATUALIZADO:


-- Criar o banco de dados
CREATE DATABASE faculdade;
-- Selecionar o banco de dados
USE faculdade;

-- Criar tabela ALUNO - DDL
-- varchar e char
-- 01211XXX

CREATE TABLE aluno (
	ra char(8) primary key,
    nome varchar(100),
    email varchar(100),
    telefone varchar(25)
);

-- Exibir os dados da tabela aluno
-- * = todos os campos/colunas
SELECT * FROM aluno;
SELECT ra, nome, email, telefone from aluno;
SELECT ra, email, nome, telefone from aluno;

-- Inserir dados na tabela aluno
INSERT INTO aluno VALUES ('01211999', 'Vivian Silva',
	'vivian.silva@bandtec.com.br', '11-987654321');
    
-- Para inserir mais de um registro
INSERT INTO aluno VALUES 
	('01211XXX', 'Vivian Aluna',
    'vivian.aluna@bandtec.com.br', '11-987655555'),
    ('01211YYY', 'Vivian Monitora',
    'vivian.monitor@bandtec.com.br', '11-987651111');

-- Inserir dados de apenas alguns campos
INSERT INTO aluno (ra, nome, telefone) VALUES 
('01211025', 'Daniel Pederzini', '11-987652345');    

-- Exibir dados dos alunos
SELECT * FROM aluno;

-- Exibir dados do aluno com um respectivo nome
SELECT * FROM aluno where nome = 'Daniel Pederzini';

-- n√£o sei o sobrenome do Daniel, o que fazer?
SELECT * FROM aluno where nome like 'Daniel%';
SELECT * FROM aluno where nome like '%Pederzini';
SELECT * FROM aluno where nome like '%i';

-- todos os alunos que a segunda letra do nome √© 'a'
SELECT * FROM aluno where nome like '_a%';
SELECT * FROM aluno where nome like '%e_ %';

-- Exibir os dados cujo o nome √© diferente de um respectivo nome
SELECT * FROM aluno where nome <> 'Vivian Silva';
SELECT * FROM aluno where nome != 'Vivian Aluna';

SELECT * FROM aluno where nome like '%n %';

-- Exibir os campos ra, nome e email da tabela aluno
SELECT ra, nome, email from aluno;

-- Atualizar o e-mail de um respectivo aluno
UPDATE aluno SET email = 'daniel@uol.com.br' 
	WHERE ra = '01211025';

-- Atualizar o nome de um respectivo aluno
UPDATE aluno SET nome = 'Vivian Monitora' 
	WHERE ra = '01211XXX';

-- Ordenar em ordem descrecente pelo nome dos alunos
select * from aluno order by nome desc;

-- Deletar a tabela aluno
-- DROP TABLE aluno;  

-- Bons estudos!


SCRIPT BANCO DE DADOS FACULDADE - TABELA ALUNO:

-- Criar o banco de dados
CREATE DATABASE faculdade;
-- Selecionar o banco de dados
USE faculdade;

-- Criar tabela ALUNO - DDL
-- varchar e char
-- 01211XXX

CREATE TABLE aluno (
	ra char(8) primary key,
    nome varchar(100),
    email varchar(100),
    telefone varchar(25)
);

-- Exibir os dados da tabela aluno
-- * = todos os campos/colunas
SELECT * FROM aluno;

-- Inserir dados na tabela aluno
INSERT INTO aluno VALUES ('01211999', 'Vivian Silva',
	'vivian.silva@bandtec.com.br', '11-987654321');
    
-- Para inserir mais de um registro
INSERT INTO aluno VALUES 
	('01211XXX', 'Vivian Aluna','vivian.aluna@bandtec.com.br', '11-987655555'),
    ('01211YYY', 'Vivian Monitora','vivian.monitor@bandtec.com.br', '11-987651111');
    
    
    
    CREATE DATABASE TECCHICKEN;
USE TECCHICKEN;

CREATE TABLE Usuario (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
nome CHAR (50),
CPF VARCHAR (11),
nomeGranja VARCHAR(50),
CNPJ CHAR (14)
);

CREATE DATABASE TECCHICKEN;
USE TECCHICKEN;

CREATE TABLE Usuario (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
nome CHAR (50),
CPF VARCHAR (11),
nomeGranja VARCHAR(50),
CNPJ CHAR (14)
);

USU√ÅRIOS NO MySQL:
ALUNO: SELECT
PROFESSOR: SELECT, INSERT, DELETE, UPDATE
    
    
create database sprint1;
use faculdade;

CREATE TABLE Atleta (
	IDatleta int primary key auto_increment,
    nome varchar(40),
    modalidade varchar(40),
    qtdMedalha int 
);

INSERT INTO Atleta values 
(null, 'Usain Bolt', 'corrida', 8),
(null, 'Oscar Schmidt', 'basquete', 6),
(null, 'Lucas Bittencourt', 'Ginastica', 4),
(null, 'Maybyner Hil√°rio', 'basquete', 5),
(null, 'Arthur Zanetti', 'Ginastica', 6),
(null, 'Frank Caldeira', 'corrida', 2);

SELECT * FROM Atleta; 


SELECT nome, qtdMedalha FROM Atleta; 


SELECT * FROM Atleta where modalidade= 'corrida';


SELECT * FROM Atleta order by modalidade;


SELECT * FROM Atleta order by qtdMedalha desc;


SELECT * FROM Atleta where nome like '%s%';


SELECT * FROM Atleta where nome like 'u%';


SELECT * FROM Atleta where nome like '%o';


SELECT * FROM Atleta where nome like '%r_';


DROP TABLE Atleta;


create database sprint2;
use faculdade;

CREATE TABLE Musica (
	IDmusica int primary key auto_increment,
    titulo varchar(40),
    artista varchar(40),
    genero varchar (40)
);

INSERT INTO Musica values
(null, 'Vt ta na bota', 'Mc Paulin da Capital','Funk'),
(null, 'So gratidao', 'Mc Paulin da Capital', 'Funk'),
(null, 'I am you', 'Ynw Melly', 'Trap'),
(null, 'Murder on my mind', 'Ynw Melly','Trap'),
(null, 'Know My Name', 'Fetty Wap', 'Rap'),
(null, 'Couple Bands', 'Fetty Wap', 'Rap'),
(null, 'Lancinho', 'Turma do Pagode', 'Pagode'),
(null, 'Cobertor de Orelha', 'Turma do Pagode', 'Pagode');


SELECT * FROM Musica;


SELECT titulo, artista FROM Musica;


SELECT * FROM Musica where genero= 'Funk';


SELECT * FROM Musica where artista='Ynw Melly';


SELECT * FROM Musica order by titulo;


SELECT * FROM Musica order by artista desc;


SELECT * FROM Musica where titulo like '%i%';


SELECT * FROM Musica where artista like 'y%';


SELECT * FROM Musica where genero like '_r%';


SELECT * FROM Musica where titulo like '%h_';


DROP TABLE Musica;
    
    
CREATE DATABASE TECCHICKEN;
USE TECCHICKEN;

CREATE TABLE Usuario (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
nome CHAR (50),
CPF VARCHAR (11),
nomeGranja VARCHAR (50),
CNPJ CHAR (14)
);

INSERT INTO Usuario VALUES 
(null, 'henrique', '85170656033', 'granja do henrique', '79838569000180'),
(null, 'luciano', '94997759007', 'granja do luciano', '39175355000157'),
(null, 'bia', '83261392037', 'granja da bia', '16398022000191'),
(null, 'tiago', '56849110055', 'granja do tiago', '22575602000100');

SELECT * FROM Usuario;

SELECT nome,  CNPJ FROM Usuario;

SELECT * FROM Usuario WHERE nomeGranja= 'granja da bia';

SELECT * FROM Usuario ORDER BY nomeGranja;

SELECT * FROM Usuario ORDER BY CNPJ DESC;

SELECT * FROM Usuario WHERE nome LIKE '%i%';

SELECT * FROM Usuario WHERE nome LIKE 'b%';

SELECT * FROM Usuario WHERE nome LIKE '%o';

SELECT * FROM Usuario WHERE nome LIKE '%n_';

DROP TABLE Usuario;
   
    
    
    Tabela  da prova:
    
    
    CREATE DATABASE ac01211089;
USE ac01211089;

CREATE TABLE Moto (
iDmoto int primary key auto_increment,
    nome varchar(50),
    placa varchar(7),
    cidade char (30)
);

INSERT INTO Moto values
(null, 'xj6 2020', 'FXZ4853', 'sao paulo'),
(null, 'honda cb 600f hornet','LRK0828','rio de janeiro'),
(null, 'bmw S1000RR', 'MOR1703', 'paraiba'),
(null, 'Honda CBR1000 RR', 'HCM4339', 'minas gerais' ),
(null, 'Yamaha YZF-R1', 'NAD5031', 'acre' ),
(null, 'bmw r 1200 gs', 'JOK9668','bahia' ),
(null, 'kawasaki zx-10r','NDF4741','roraima');

SELECT * FROM Moto;

SELECT nome, cidade FROM Moto;

SELECT * FROM Moto where cidade= 'sao paulo';

SELECT * FROM Moto where placa= 'NDF4741';

SELECT * FROM Moto order by cidade;

SELECT * FROM Moto order by nome desc;


SELECT * FROM Moto where nome like '%r_';

SELECT * FROM Moto where cidade like 's%';

SELECT * FROM Moto where placa like '_o%';

SELECT * FROM Moto where nome like '%j%';

UPDATE Moto set placa = 'LRK0828' where iDmoto = 'KEV6403';
SELECT * FROM Moto;

DELETE FROM Moto where idMoto =5;
SELECT * FROM Moto;

DROP TABLE Moto;




CREATE DATABASE Temperatura;
USE Temperatura;

CREATE TABLE Temperatura (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
temperatura CHAR (2),
dia DATE,
hora time
);

INSERT INTO Temperatura VALUES 
(null, '41', '2020-10-21', '12:00:22'),
(null, '21', '2021-01-03', '17:05:50'),
(null, '23', '2012-04-14', '10:30:23'),
(null, '32', '2001-06-11', '14:52:20');


SELECT * FROM Temperatura;

SELECT temperatura, hora FROM Temperatura;

SELECT * FROM Temperatura WHERE dia= '2001-06-11';

SELECT * FROM Temperatura ORDER BY dia;

SELECT * FROM Temperatura ORDER BY hora DESC;

SELECT * FROM Temperatura WHERE temperatura LIKE '%23%';

SELECT * FROM Temperatura WHERE dia LIKE '2021-01-03%';

SELECT * FROM Temperatura WHERE hora LIKE '%12:00:22';

SELECT * FROM Temperatura WHERE temperatura LIKE '32%';

DROP TABLE Temperatura;



-- Criar database Jornal
create database Jornal;

-- Usar Jornal
use jornal;

-- Criar tabela Jornal

create table Jornal (
idJornal int primary key auto_increment,
nomeJornal varchar (45)
);

-- Criar tabela Reporter

create table Reporter (
idReporter int primary key,
nomeReporter varchar (45),
dataNasc date,
sexo char (1),
check (sexo='m'or sexo='f'),
fkJornal int,
foreign key (fkJornal) references Jornal (idJornal)
);

-- Inserir dados na Tabela Jornal

insert into Jornal values 
(null,'Estadao');
-- Inserir dados na Tabela Reporter
insert into Reporter values
(1,'Mateus','1996-06-12','m', 1),
(2,'Larissa','2000-07-13','f', 2);

-- Selecionar todos os dados das tabelas

select * from Jornal;

select * from Reporter;

Update Jornal set nomeJornal='Datafolha' Where idJornal=1;

Delete from Jornal Where idJornal=1;

SCRIPT DO REFOR√áO

-- Criando banco de dados
CREATE DATABASE Produtos;

-- Usando banco de dados
USE Produtos;

-- Criando tabela Categoria
CREATE TABLE Categoria (
idCategoria INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45)
);

-- Criando tabela Produtos
CREATE TABLE Produtos (
idProduto INT PRIMARY KEY AUTO_INCREMENT,
descricao VARCHAR (100),
marca VARCHAR (50),
fkCategoria INT,
FOREIGN KEY (fkCategoria) REFERENCES Categoria (idCategoria)
)AUTO_INCREMENT = 100; 

-- Criando tabela Loja
CREATE TABLE Loja (
idLoja INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45),
DataFunc DATE
)AUTO_INCREMENT = 1000;

-- Criando tabela associativa
CREATE TABLE ProdutoLoja (
fkProduto INT,
FOREIGN KEY (fkProduto) REFERENCES Produtos (idProduto),
fkLoja INT, 
FOREIGN KEY (fkLoja) REFERENCES Loja (idLoja),
PRIMARY KEY (fkProduto, fkLoja),
preco DECIMAL (6,2)
);

 -- Inserindo dados na tabela categoria
INSERT INTO Categoria	(nome)
VALUES 					('Chocolate'),
						('Refrigerante');

-- Inserindo dados na tabela produtos
INSERT INTO Produtos	(descricao, marca, fkCategoria)
VALUES					('Sensa√ß√£o', 'Lacta', 1),
						('Diamante negro', 'Nestle', 1),
                        ('Talento', 'Garoto', 1),
                        ('Coca-cola', 'Coca', 2),
                        ('Fanta uva', 'Fanta', 2),
                        ('Sprit lim√£o', 'Sprit', 2);

-- Inserindo dados na tabela loja 
INSERT INTO Loja		(nome, dataFunc)
VALUES					('Loja 1', '2000-01-01'),
						('Loja 2', '2001-12-12');

-- Inserindo dados na tabela ProdutoLoja
INSERT INTO ProdutoLoja	(fkProduto, fkLoja, preco)
VALUES					(100, 1000, 5.00),
						(101, 1000, 6.50),
                        (102, 1000, 4.00),
                        (104, 1000, 7.90),
                        (100, 1001, 6.50),
                        (101, 1001, 5.80),
                        (103, 1001, 4.60),
                        (105, 1001, 6.80);

-- Exibindo as tabelas separadamente
SELECT * FROM Categoria;
SELECT * FROM Produtos;
SELECT * FROM Loja;
SELECT * FROM ProdutoLoja;

-- Exibindo dados das categorias e dos seus produtos
SELECT Categoria.*, idProduto, descricao, marca FROM Categoria
INNER JOIN Produtos
ON	idCategoria = fkCategoria;

-- 	Exibindo dados de uma derterminada categoria e os dados dos seus produtos
SELECT Categoria.*, idProduto, descricao, marca FROM Categoria
INNER JOIN Produtos
ON	idCategoria = fkCategoria
WHERE idCategoria = 1;

-- Exibindo a m√©dia e as somas dos produtos em geral
SELECT  ROUND(AVG(preco), 2) AS `M√©dia dos pre√ßos`,
		SUM(preco) AS `Soma dos pre√ßos` FROM ProdutoLoja; 
        
-- Exibindo o menor e o maior pre√ßo dos produtos em geral
SELECT 	MAX(preco) AS `Maior pre√ßo`,
		MIN(preco) AS `Menor pre√ßo` FROM ProdutoLoja;
        
-- Exibindo os dados de um determinado produto, os dados das lojas que o vendem e seu pre√ßo em cada loja
SELECT idProduto, descricao, marca, idLoja, nome, dataFunc, preco FROM 	ProdutoLoja
INNER JOIN Produtos
ON fkProduto = idProduto
INNER JOIN Loja 
ON fkLoja = idLoja
WHERE idProduto = 101;

-- Exibindo os dados dos produtos, os dados das categorias correspondentes, os dados das lojas correspondentes e os pre√ßos dos produtos em cada loja
SELECT idProduto, descricao, marca, idCategoria, Categoria.nome, idLoja, Loja.nome, dataFunc, preco FROM 	ProdutoLoja
INNER JOIN Produtos
ON fkProduto = idProduto
INNER JOIN Categoria
ON fkCategoria = idCategoria
INNER JOIN Loja 
ON fkLoja = idLoja;

-- Exibindo a identifica√ß√£o do produto, a m√©dia e a soma dos pre√ßos dos produtos, agrupadas por produto
SELECT fkProduto, ROUND(AVG(preco), 2) AS `M√©dia dos pre√ßos`,
SUM(preco) AS `Soma de pre√ßos`	FROM ProdutoLoja GROUP BY fkProduto;	
                    
                    
-- Exibindo a identifica√ß√£o da loja, a m√©dia e a soma dos pre√ßos dos produtos, agrupadas por loja
SELECT fkLoja, ROUND(AVG(preco), 2) AS `M√©dia dos pre√ßos`,
SUM(preco)	AS `Soma de pre√ßos` FROM ProdutoLoja GROUP BY fkLoja;

-- Exibindo a identifica√ß√£o do produto, o menor e o maior pre√ßo, agrupado por produto
SELECT fkProduto, MIN(preco) AS `Menor pre√ßo`,
MAX(preco) AS `Maior pre√ßo`	FROM ProdutoLoja GROUP BY fkProduto;
                    
-- Exibir a identifica√ß√£o da loja, o menor e o maior pre√ßo, agrupado por loja
SELECT fkLoja, MIN(preco) AS `Menor pre√ßo`,
MAX(preco) AS `Maior pre√ßo`	FROM ProdutoLoja GROUP BY fkLoja;
MAX(preco) AS `Maior pre√ßo`	FROM ProdutoLoja GROUP BY fkLoja;

SELECT * FROM categoria;
SELECT * FROM produtos;

INSERT INTO categoria VALUES
(null,'eletr√¥nico');
 
SELECT * FROM categoria LEFT JOIN produtos ON idCategoria = fkCategoria;
SELECT * FROM categoria INNER JOIN produtos ON idCategoria = fkCategoria;
SELECT * FROM categoria RIGHT JOIN produtos 
    ON idCategoria = fkCategoria 
    WHERE fkCategoria is not null;
SELECT * FROM categoria RIGHT JOIN produtos 
    ON idCategoria = fkCategoria 
    WHERE fkCategoria is null;

INSERT INTO produtos VALUES
(null,'Smartphome','Samsung',null);
 
/*
-- Criando banco de dados
CREATE DATABASE Produtos;

-- Usando banco de dados
USE Produtos;

-- Criando tabela Categoria
CREATE TABLE Categoria (
	idCategoria	INT PRIMARY KEY AUTO_INCREMENT,
    nome		VARCHAR(45)
);

-- Criando tabela Produtos
CREATE TABLE Produtos (
	idProduto	INT PRIMARY KEY AUTO_INCREMENT,
    descricao	VARCHAR(100),
	marca		VARCHAR(50),
    fkCategoria	INT,
    FOREIGN KEY (fkCategoria) REFERENCES Categoria (idCategoria)
)AUTO_INCREMENT = 100;

-- Criando tabela Loja
CREATE TABLE Loja (
	idLoja		INT PRIMARY KEY AUTO_INCREMENT,
    nome		VARCHAR(45),
    dataFunc	DATE 
)AUTO_INCREMENT = 1000;

-- Criando tabela associativa
CREATE TABLE ProdutoLoja (
	fkProduto	INT,
    FOREIGN KEY (fkProduto) REFERENCES Produtos (idProduto),
    fkLoja		INT,
    FOREIGN KEY (fkLoja) REFERENCES Loja (idLoja),
    PRIMARY KEY (fkProduto, fkLoja),
    preco		DECIMAL(6,1)
);

-- Inserindo dados na tabela categoria
INSERT INTO Categoria	(nome)
VALUES 					('Chocolate'),
						('Refrigerante');
                    
-- Inserindo dados na tabela produtos
INSERT INTO Produtos	(descricao, marca, fkCategoria)
VALUES					('Sensa√ß√£o', 'Lacta', 1),
						('Diamante negro', 'Nestle', 1),
                        ('Talento', 'Garoto', 1),
                        ('Coca-cola', 'Coca', 2),
                        ('Fanta uva', 'Fanta', 2),
                        ('Sprit lim√£o', 'Sprit', 2);
                        
-- Inserindo dados na tabela loja 
INSERT INTO Loja		(nome, dataFunc)
VALUES					('Loja 1', '2000-01-01'),
						('Loja 2', '2001-12-12');

-- Inserindo dados na tabela ProdutoLoja
INSERT INTO ProdutoLoja	(fkProduto, fkLoja, preco)
VALUES					(100, 1000, 5.00),
						(101, 1000, 6.50),
                        (102, 1000, 4.00),
                        (104, 1000, 7.90),
                        (100, 1001, 6.50),
                        (101, 1001, 5.80),
                        (103, 1001, 4.60),
                        (105, 1001, 6.80);

-- Exibindo as tabelas separadamente
SELECT * FROM Categoria;
SELECT * FROM Produtos;
SELECT * FROM Loja;
SELECT * FROM ProdutoLoja;

-- Exibindo dados das categorias e dos seus produtos
SELECT Categoria.*, idProduto, descricao, marca FROM 	Categoria
INNER JOIN		Produtos
ON				idCategoria = fkCategoria;

-- 	Exibindo dados de uma derterminada categoria e os dados dos seus produtos
SELECT Categoria.*, idProduto, descricao, marca FROM 	Categoria
INNER JOIN 		Produtos
ON				idCategoria = fkCategoria
WHERE			idCategoria = 1;

-- Exibindo a m√©dia e as somas dos produtos em geral
SELECT  ROUND(AVG(preco), 2) AS `M√©dia dos pre√ßos`,
		SUM(preco) AS `Soma dos pre√ßos` FROM ProdutoLoja; 
        
-- Exibindo o menor e o maior pre√ßo dos produtos em geral
SELECT 	MAX(preco) AS `Maior pre√ßo`,
		MIN(preco) AS `Menor pre√ßo` FROM ProdutoLoja;
        
-- Exibindo os dados de um determinado produto, os dados das lojas que o vendem e seu pre√ßo em cada loja
SELECT idProduto, descricao, marca, idLoja, nome, dataFunc, preco FROM 	ProdutoLoja
INNER JOIN 		Produtos
ON				fkProduto = idProduto
INNER JOIN		Loja 
ON 				fkLoja = idLoja
WHERE 			idProduto = 101;

-- Exibindo os dados dos produtos, os dados das categorias correspondentes, os dados das lojas correspondentes e os pre√ßos dos produtos em cada loja
SELECT idProduto, descricao, marca, idCategoria, Categoria.nome, idLoja, Loja.nome, dataFunc, preco FROM 	ProdutoLoja
INNER JOIN 		Produtos
ON				fkProduto = idProduto
INNER JOIN		Categoria
ON				fkCategoria = idCategoria
INNER JOIN		Loja 
ON 				fkLoja = idLoja;

-- Exibindo a identifica√ß√£o do produto, a m√©dia e a soma dos pre√ßos dos produtos, agrupadas por produto
SELECT fkProduto, 	ROUND(AVG(preco), 2) AS `M√©dia dos pre√ßos`,
					SUM(preco) AS `Soma de pre√ßos`	FROM ProdutoLoja GROUP BY fkProduto;	
                    
                    
-- Exibindo a identifica√ß√£o da loja, a m√©dia e a soma dos pre√ßos dos produtos, agrupadas por loja
SELECT fkLoja, 	ROUND(AVG(preco), 2) AS `M√©dia dos pre√ßos`,
				SUM(preco)	AS `Soma de pre√ßos` FROM ProdutoLoja GROUP BY fkLoja;

-- Exibindo a identifica√ß√£o do produto, o menor e o maior pre√ßo, agrupado por produto
SELECT fkProduto, 	MIN(preco) AS `Menor pre√ßo`,
					MAX(preco) AS `Maior pre√ßo`	FROM ProdutoLoja GROUP BY fkProduto;
                    
-- Exibir a identifica√ß√£o da loja, o menor e o maior pre√ßo, agrupado por loja
SELECT fkLoja, 	MIN(preco) AS `Menor pre√ßo`,
				MAX(preco) AS `Maior pre√ßo`	FROM ProdutoLoja GROUP BY fkLoja;


SCRIPT PROVA:

create database caseFuncionario;
use caseFuncionario;

create table Funcionario (
   idFunc int primary key auto_increment,
   nome varchar(40),
   genero char(1),
   check (genero = 'm' or genero ='f' or genero = 'n'),
   -- no MySQL, vers√µes anteriores a 8.0.16, devem usar enum no lugar do check:
   -- genero enum('m','f','n'),
   salario double, -- decimal(7,2) 7 significa que o n√∫mero tem 7 digitos, considerando os digitos antes da 
                         -- virgula e os depois
                         -- 2 significa que tem 2 diginos ap√≥s a v√≠rgula
                         -- decimal(7,2) significa um n√∫mero do tipo 99999,99
   check (salario > 0),  -- isso n√£o funciona em vers√µes anteriores a 8.0.16 do MySQL
                         -- se fosse nota: check (nota >= 0 and nota <= 10)
   cpf char(11) unique,
   fkSupervisor int,  -- implementa√ß√£o de um relacionamento recursivo um para muitos
   foreign key(fkSupervisor) references Funcionario(idFunc)
) auto_increment = 1000;

select * from Funcionario;
desc Funcionario;

-- o comando a seguir n√£o funciona pois est√° tentando inserir 'x' para genero
/*insert into Funcionario values
    (null, 'Maria Aparecida','x',15000,'15915998788', null);
*/
-- inser√ß√£o de um funcion√°rio, que n√£o tem supervisor    
insert into Funcionario values
    (null, 'Maria Aparecida','f',15000, '15915998788',null);

-- Inserir o mesmo cpf - unique - Este comando dar√° erro
insert into Funcionario values
    (null, 'Maria Desaparecida','f', 15000, '15915998788', null);
    
insert into Funcionario values
    (null, 'Vit√≥ria','f', 50000, '15915915877', 1000);
    
update funcionario set fkSupervisor = 1004 where idFunc = 1000;
    
-- inser√ß√£o de mais um funcion√°rio (supervisor deste funcion√°rio ser√° a Maria Aparecida - id 1000)    
insert into Funcionario values
	(null, 'Jos√© da Silva','m',5000,'12345678999', 1000);
-- inser√ß√£o de mais um funcion√°rio (supervisor deste funcion√°rio ser√° o Jos√© da Silva - id 1001)
insert into Funcionario values
    (null, 'Jo√£o Oliveira','m', 2000,'65498788844',1001);

-- Exibir os dados dos funcion√°rios e dos supervisores
-- correspondentes
-- se existissem 2 tabelas, uma Funcionario e outra Supervisor, ficaria assim o comando:
-- select * from funcionario join supervisor on fksupervisor = idfunc;
-- mas como a tabela √© a mesma, tanto de Funcionario como de Supervisor, ent√£o o certo √©:
select * from funcionario as func join funcionario as supervisor 
													on func.fksupervisor = supervisor.idfunc;
                                                    
select func.nome as NomeFunc, supervisor.nome as Supervisor 
				from funcionario as func join funcionario as supervisor 
								on func.fksupervisor = supervisor.idfunc;
        
-- Parei aqui!!

-- Cria√ß√£o da tabela Dependente, que √© uma entidade fraca em rela√ß√£o a Funcionario 
create table Dependente (
   fkFunc int,
   foreign key (fkFunc) references Funcionario(idFunc),
   idDep int,
   primary key (fkFunc, idDep),  -- chave prim√°ria composta
   nomeDep varchar(40),
   dataNasc date,
   parentesco varchar(45)
);
-- Inser√ß√£o de dependentes
insert into Dependente values
   (1000, 1, 'Ana', '2012-10-01','filha'),
   (1000, 2, 'Paulo', '1984-03-05', 'marido'),
   (1001, 1, 'Ant√¥nio', '1968-09-06', 'pai'),
   (1002, 1, 'Clara', '2014-06-01', 'irm√£'),
   (1004, 1, 'Vit√≥rio', '1994-06-01', 'irm√£o');
   
insert into Dependente values
   (1002, 2, 'Gema', '2014-06-01', 'irm√£');
   
insert into Dependente values
   (1002, 4, 'Casca', '2014-06-01', 'irm√£');

select * from funcionario;
-- Exibe a tabela Dependente
select * from Dependente;

-- Exibe os funcion√°rios e seus dependentes
select * from funcionario
inner join dependente on fkFunc = idFunc; 

-- Atualizar os dados de um dependente;
update Dependente set nomeDep='Paulo Jonas' where fkFunc=1000 and idDep = 2;

-- Inserir dados de um funcion√°rio sem supervisor.
insert into Funcionario values
    (null, 'Vivian','f',1100, '12345678779',null);

-- Exibir os dados dos funcion√°rios com e sem dependentes.
select * from funcionario left join dependente on fkFunc = idFunc;

-- Exibir os dados dos funcion√°rios sem dependentes.
select * from funcionario
left join dependente on fkFunc = idFunc
where fkFunc is null;

-- Exibir os dados dos funcion√°rios, seus respectivos supervisores e seus dependentes.
select * from funcionario as f
inner join funcionario as s on s.idFunc = f.fkSupervisor
inner join dependente on fkFunc = f.idFunc;

-- Exibir os dados dos funcion√°rios e seus respectivos supervisores, 
-- funcion√°rios sem supervisor, e seus respectivos dependentes.
select * from funcionario as f
left join funcionario as s on s.idFunc = f.fkSupervisor
inner join dependente on fkFunc = f.idFunc;

SEGUNDA OP√á√ÉO: 

-- LUIZ HENRIQUE OLIVEIRA NARDI RA: 01211089
CREATE DATABASE Exercicio11;
USE Exercicio11;

-- TABELA DEPARTAMENTO
CREATE TABLE Departamento (
idDepto INT PRIMARY KEY,
nomeDepto VARCHAR (40),
fkGerente INT,
dataInicioGer DATE
);

-- TABELA FUNCIONARIO
CREATE TABLE Funcionario (
idFunc INT PRIMARY KEY,
nomeFunc VARCHAR (30),
salario FLOAT,
CHECK (salario > 0),
sexo CHAR (1),
CHECK (sexo = 'm' OR sexo = 'f'),
fkSupervisor INT,
dataNasc DATE,
fkDepto INT,
FOREIGN KEY (fkDepto) REFERENCES Departamento (idDepto)
);

-- TABELA PROJETO
CREATE TABLE Projeto (
idProj INT PRIMARY KEY,
nomeProj VARCHAR (90),
localProj VARCHAR (80),
fkDepto INT,
FOREIGN KEY (fkDepto) REFERENCES Departamento (idDepto)
);

-- TABELA FUNCPROJ
CREATE TABLE FuncProj (
fkFunc INT,
fkProj INT,
PRIMARY KEY (fkFunc, fkProj),
horas DECIMAL (3,1),
FOREIGN KEY (fkFunc) REFERENCES Funcionario (idFunc),
FOREIGN KEY (fkProj) REFERENCES Projeto (idProj)
);

ALTER TABLE Departamento ADD FOREIGN KEY (fkGerente) REFERENCES Funcionario (idFunc);

INSERT INTO Departamento VALUES 
(105, 'Pesquisa', NULL, '2008-05-22'),
(104, 'Administra√ß√£o', NULL, '2015-01-01'),
(101, 'Matriz', NULL, '2001-06-19');

INSERT INTO Funcionario VALUES 
(1, 'Jo√£o Silva', 3500, 'm', 2, '1985-01-09', 105),
(2, 'Fernando Wong', 4500, 'm', 8, '1975-12-08', 105),
(3, 'Alice Sousa', 2500, 'f', 7, '1988-01-09', 104),
(4, 'Janice Morais', 4300, 'f', 8, '1970-06-20', 104),
(5, 'Ronaldo Lima', 3800, 'm', 1, '1982-09-15', 105),
(6, 'Joice Leite', 2500, 'f', 1, '1992-01-09', 105),
(7, 'Antonio Pereira', 2500, 'm', 4, '1989-03-29', 104),
(8, 'Juliano Brito', 5500, 'm', NULL, '1957-11-10', 101);

INSERT INTO Projeto VALUES 
(1, 'Produto X', 'Santo Andr√©', 105),
(2, 'Produto Y', 'Itu', 105),
(3, 'Produto Z', 'S√£o Paulo', 105),
(10, 'Informatiza√ß√£o', 'Mau√°', 104),
(20, 'Reorganiza√ß√£o', 'S√£o Paulo', 101),
(30, 'Beneficios', 'Mau√°', 104);

INSERT INTO FuncProj VALUES 
(1, 1, 32.5),
(1, 2, 7.5),
(5, 3, 40.0),
(6, 1, 20.0),
(6, 2, 20.0),
(2, 2, 10.0),
(2, 3, 10.0),
(2, 10, 10.0),
(2, 20, 10.0),
(3, 30, 30.0),
(3, 10, 10.0),
(7, 10, 35.0),
(7, 30, 5.0),
(4, 30, 20.0),
(4, 20, 15.0),
(8, 20, NULL);

UPDATE Departamento SET fkGerente = 2 WHERE idDepto = 105;

UPDATE Departamento SET fkGerente = 7 WHERE idDepto = 104;

UPDATE Departamento SET fkGerente = 8 WHERE idDepto = 101;

SELECT * FROM Departamento;

SELECT * FROM Funcionario;

SELECT * FROM Projeto;

SELECT * FROM FuncProj;

-- INFELIZMENTE N√ÉO VAI DAR CERTO, POIS O IDFUNC N√ÉO PODE SER NULO.
INSERT INTO Funcionario VALUES
(null, "Cecilia Ribeiro", 2800, "f", null, "1980-04-05", 104);

-- N√ÉO VAI DAR CERTO, O ID 3 EST√Å DUPLICADO.
INSERT INTO Funcionario VALUES
(3, "Alice Souza", 2800, "f", 4, "1980-04-05", 104);

-- N√ÉO VAI DAR CERTO, O FK 107 N√ÉO EXISTE.
INSERT INTO Funcionario VALUES 
(9, "Cec√≠lia Ribeiro", 2800, "f", 4, "1980-04-05", 107);

-- FUNCIONOUUUU ;)
INSERT INTO Funcionario VALUES
(9, "Cec√≠lia Ribeiro", 2800, "f", 4, "1980-04-05", 104);

-- FUNCIONOUUUU ;)
DELETE FROM FuncProj WHERE fkFunc = 3 AND fkProj = 10;

-- FUNCIONARIO EST√Å ASSOCIADO A UM PROJETO.
DELETE FROM Funcionario WHERE idFunc = 4;

-- FUNCIONARIO EST√Å ASSOCIADO A UM PROJETO.
DELETE FROM Funcionario WHERE idFunc = 2;

-- FUNCIONOUUUU ;)
UPDATE Funcionario SET salario = 2800 WHERE idFunc = 3;

-- FUNCIONOUUUU ;)
UPDATE Funcionario SET fkDepto = 101 WHERE idFunc = 3;

-- N√ÉO FUNCIONOU, POIS FK 107 N√ÉO EXISTE.
UPDATE Funcionario SET fkDepto = 107 WHERE idFunc = 3;

SELECT nomeFunc, dataNasc, salario FROM Funcionario WHERE nomeFunc = "Jo√£o Silva";

SELECT DISTINCT salario FROM Funcionario;

SELECT salario FROM Funcionario ORDER BY nomeFunc;

SELECT * FROM Funcionario ORDER BY salario DESC;

SELECT * FROM Funcionario WHERE salario > 2000 AND salario < 4000;

SELECT nomeFunc, salario FROM Funcionario WHERE nomeFunc LIKE "j%";

SELECT nomeFunc, salario FROM Funcionario WHERE nomeFunc LIKE "%a";

SELECT nomeFunc, salario FROM Funcionario WHERE nomeFunc LIKE "__n%";

SELECT nomeFunc, dataNasc FROM Funcionario WHERE nomeFunc LIKE "%s____";

SELECT * FROM Funcionario INNER JOIN Departamento ON fkDepto = idDepto WHERE nomeDepto = "Pesquisa";

SELECT * FROM Funcionario INNER JOIN Departamento ON fkDepto = idDepto WHERE nomeDepto = "Pesquisa" AND salario > 3500;

SELECT * FROM Funcionario INNER JOIN Departamento ON fkDepto = idDepto WHERE nomeDepto = "Pesquisa" AND nomeFunc LIKE "J%";

SELECT Funcionario.idFunc AS Funcionario, Funcionario.nomeFunc AS NomeFuncionario, Supervisor.idFunc AS idSupervisor, Supervisor.nomeFunc AS NomeSupervisor
FROM Funcionario AS Funcionario
INNER JOIN Funcionario AS Supervisor
ON funcionario.fkSupervisor = Supervisor.idFunc;

SELECT Proj.idProj AS idProjeto, Proj.fkDepto AS 'Departamento' , Ger.nomeFunc AS Gerente, Ger.dataNasc AS 'Data Nascimento' FROM Projeto AS Proj
INNER JOIN Departamento ON fkDepto = idDepto INNER JOIN Funcionario AS Ger ON fkGerente = idFunc 
WHERE Proj.localProj = 'S√£o Paulo';

SELECT Func.idFunc AS idFuncionario, Func.nomeFunc AS Funcionario, FuncProj.fkProj AS Projeto, Proj.nomeProj AS 'Nome Projeto', FuncProj.horas AS 'Quantidade de Horas' FROM FuncProj AS FuncProj
INNER JOIN Funcionario AS Func ON fkFunc = idFunc INNER JOIN Projeto AS Proj ON fkProj = idProj;

SELECT nomeFunc FROM Funcionario WHERE dataNasc < "1980-01-01";

SELECT count(DISTINCT(salario)) AS "Sal√°rios diferentes" FROM Funcionario;

SELECT count(DISTINCT(localProj)) AS "Locais diferentes" FROM Projeto;

SELECT TRUNCATE(AVG(salario),2) AS "M√©dia salarial", TRUNCATE(sum(salario),2) AS "Soma dos sal√°rios" FROM Funcionario;

SELECT min(salario), max(salario) FROM Funcionario;

SELECT idDepto, TRUNCATE(AVG(salario),2) AS "M√©dia salarial", TRUNCATE(sum(salario),2) AS "Soma dos sal√°rios" FROM Funcionario INNER JOIN Departamento ON idDepto = fkDepto GROUP BY idDepto;

SELECT idDepto, min(salario), max(salario) FROM Funcionario INNER JOIN Departamento ON idDepto = fkDepto GROUP BY idDepto;

INSERT INTO Funcionario VALUES 
(10, "Jos√© da Silva", 1800, "m", 3, "2000-10-12", NULL),
(11, "Benedito Almeida", 1200, "m", 5, "2001-09-01", NULL);

INSERT INTO Departamento VALUES 
(110, "RH", 3, "2018-11-10");


TERCEIRA OP√á√ÉO:

USE faculdade;

CREATE TABLE aula (
	idAula int primary key auto_increment,
    nomeAula varchar(75),
    tipo char(1),
    check (tipo = 'o' or tipo = 'h' or tipo = 'p'),
    dtAula date,
    mensagem varchar(100)
);

INSERT INTO aula values 
	(null, 'Apresenta√ß√£o da disciplina e primeiros conceitos',
		'o', '2021-02-04', 'Conhecendo Banco de Dados'),
    (null, 'Continua√ß√£o de conceitos e primeiros comandos SQL',
		'o', '2021-02-11', 'O primeiro comando a gente nunca esquece');
    
SELECT * FROM aula;

INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Permiss√£o de usu√°rio e comandos gerais', 'p', 
    '2021-02-18', 'Sejam bem vindos!');
  
INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Linha de comando - CLI - MySQL Server Client', 'p', 
    '2021-02-25', 'Codando no client!');

    
INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Avalia√ßao Continuada I', 'p', 
    '2021-03-04', 'Boa prova!');
    
INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Entreg√°veis de banco de dados', 'o', 
    '2021-03-11', 'Boa Sprint!');
    
INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Chave estrangeira, Constraint e Aliases', 'o', 
    '2021-03-18', 'Agora complicou! =)');
    
-- Aula 07
SELECT * FROM aula;
select * from aluno;

-- criar a tabela chamada
CREATE TABLE chamada (
	idChamada int primary key auto_increment,
    fkAluno char(8), -- chave estrangeira referente a tabela aluno
    foreign key (fkAluno) references aluno(ra), -- configura√ß√£o chave estrangeira fkAluno
    dtPresenca datetime default current_timestamp,
    presenca char(3),
    check (presenca = 'sim' or presenca = 'n√£o'),
    fkAula int, -- chave estrangeira referente a tabela aula
    foreign key (fkAula) references aula(idAula) -- configura√ß√£o chave estrangeira fkAula
) auto_increment=20000;

-- exibir os dados da tabela chamada;
select * from chamada;

-- inserir dados na tabela chamada;
insert into chamada (fkAluno, presenca, fkAula) values
	('01211999','sim',7);
insert into chamada (fkAluno, presenca, fkAula) values
	('01211025','sim',7);
    
-- exibir todos os dados da tabela chamada e o nome do aluno
select chamada.*, aluno.nome from aluno join chamada 
	on fkAluno = ra;
 
-- exibir todos os dados da tabela chamada e a mensagem da aula do dia 18/03.
select chamada.*, aula.mensagem from aula inner join chamada 
	on fkAula = idAula where dtAula = '2021-03-18';

-- AVAN√áADO - JOIN ENTRE 3 TABELAS
select * from aluno join chamada on fkAluno = ra
	join aula on fkAula = idAula;
    
-- Bon estudos!
	use faculdade;
    select * from aula;
    
    start transaction;
    
    insert into aula (nomeAula, tipo, dtAula, mensagem) values
    ('Dicion√°rio de Dados e Start Transaction', 'o',
    '2021-05-13','S√≥ alegria!');
    
    select * from aula;
    rollback;
    
    select * from aula;
    
    
    
    QUARTA OP√á√ÉO:
    
    create database caseFuncionario;
use caseFuncionario;

create table Funcionario (
   idFunc int primary key auto_increment,
   nome varchar(40),
   genero char(1),
   check (genero = 'm' or genero ='f' or genero = 'n'),
   -- no MySQL, vers√µes anteriores a 8.0.16, devem usar enum no lugar do check:
   -- genero enum('m','f','n'),
   salario double, -- decimal(7,2) 7 significa que o n√∫mero tem 7 digitos, considerando os digitos antes da 
                         -- virgula e os depois
                         -- 2 significa que tem 2 diginos ap√≥s a v√≠rgula
                         -- decimal(7,2) significa um n√∫mero do tipo 99999,99
   check (salario > 0),  -- isso n√£o funciona em vers√µes anteriores a 8.0.16 do MySQL
                         -- se fosse nota: check (nota >= 0 and nota <= 10)
   cpf char(11) unique,
   fkSupervisor int,  -- implementa√ß√£o de um relacionamento recursivo um para muitos
   foreign key(fkSupervisor) references Funcionario(idFunc)
) auto_increment = 1000;

select * from Funcionario;
desc Funcionario;

-- o comando a seguir n√£o funciona pois est√° tentando inserir 'x' para genero
/*insert into Funcionario values
    (null, 'Maria Aparecida','x',15000,'15915998788', null);
*/
-- inser√ß√£o de um funcion√°rio, que n√£o tem supervisor    
insert into Funcionario values
    (null, 'Maria Aparecida','f',15000, '15915998788',null);

-- Inserir o mesmo cpf - unique - Este comando dar√° erro
insert into Funcionario values
    (null, 'Maria Desaparecida','f', 15000, '15915998788', null);
    
-- inser√ß√£o de mais um funcion√°rio (supervisor deste funcion√°rio ser√° a Maria Aparecida - id 1000)    
insert into Funcionario values
	(null, 'Jos√© da Silva','m',5000,'12345678999', 1000);
-- inser√ß√£o de mais um funcion√°rio (supervisor deste funcion√°rio ser√° o Jos√© da Silva - id 1001)
insert into Funcionario values
    (null, 'Jo√£o Oliveira','m', 2000,'65498788844',1001);

-- Exibir os dados dos funcion√°rios e dos supervisores
-- correspondentes
-- se existissem 2 tabelas, uma Funcionario e outra Supervisor, ficaria assim o comando:
-- select * from funcionario join supervisor on fksupervisor = idfunc;
-- mas como a tabela √© a mesma, tanto de Funcionario como de Supervisor, ent√£o o certo √©:
select * from funcionario as func join funcionario as supervisor 
															on func.fksupervisor = supervisor.idfunc;
        
-- Parei aqui!!

create database caseFuncionario;
use caseFuncionario;

create table Funcionario (
   idFunc int primary key auto_increment,
   nome varchar(40),
   genero char(1),
   check (genero = 'm' or genero ='f' or genero = 'n'),
   -- no MySQL, vers√µes anteriores a 8.0.16, devem usar enum no lugar do check:
   -- genero enum('m','f','n'),
   salario double, -- decimal(7,2) 7 significa que o n√∫mero tem 7 digitos, considerando os digitos antes da 
                         -- virgula e os depois
                         -- 2 significa que tem 2 diginos ap√≥s a v√≠rgula
                         -- decimal(7,2) significa um n√∫mero do tipo 99999,99
   check (salario > 0),  -- isso n√£o funciona em vers√µes anteriores a 8.0.16 do MySQL
                         -- se fosse nota: check (nota >= 0 and nota <= 10)
   cpf char(11) unique,
   fkSupervisor int,  -- implementa√ß√£o de um relacionamento recursivo um para muitos
   foreign key(fkSupervisor) references Funcionario(idFunc)
) auto_increment = 1000;

select * from Funcionario;
desc Funcionario;

-- o comando a seguir n√£o funciona pois est√° tentando inserir 'x' para genero
/*insert into Funcionario values
    (null, 'Maria Aparecida','x',15000,'15915998788', null);
*/
-- inser√ß√£o de um funcion√°rio, que n√£o tem supervisor    
insert into Funcionario values
    (null, 'Maria Aparecida','f',15000, '15915998788',null);

-- Inserir o mesmo cpf - unique - Este comando dar√° erro
insert into Funcionario values
    (null, 'Maria Desaparecida','f', 15000, '15915998788', null);
    
insert into Funcionario values
    (null, 'Vit√≥ria','f', 50000, '15915915877', 1000);
    
update funcionario set fkSupervisor = 1004 where idFunc = 1000;
    
-- inser√ß√£o de mais um funcion√°rio (supervisor deste funcion√°rio ser√° a Maria Aparecida - id 1000)    
insert into Funcionario values
	(null, 'Jos√© da Silva','m',5000,'12345678999', 1000);
-- inser√ß√£o de mais um funcion√°rio (supervisor deste funcion√°rio ser√° o Jos√© da Silva - id 1001)
insert into Funcionario values
    (null, 'Jo√£o Oliveira','m', 2000,'65498788844',1001);

-- Exibir os dados dos funcion√°rios e dos supervisores
-- correspondentes
-- se existissem 2 tabelas, uma Funcionario e outra Supervisor, ficaria assim o comando:
-- select * from funcionario join supervisor on fksupervisor = idfunc;
-- mas como a tabela √© a mesma, tanto de Funcionario como de Supervisor, ent√£o o certo √©:
select * from funcionario as func join funcionario as supervisor 
													on func.fksupervisor = supervisor.idfunc;
                                                    
select func.nome as NomeFunc, supervisor.nome as Supervisor 
				from funcionario as func join funcionario as supervisor 
								on func.fksupervisor = supervisor.idfunc;
        
-- Parei aqui!!

-- Cria√ß√£o da tabela Dependente, que √© uma entidade fraca em rela√ß√£o a Funcionario 
create table Dependente (
   fkFunc int,
   foreign key (fkFunc) references Funcionario(idFunc),
   idDep int,
   primary key (fkFunc, idDep),  -- chave prim√°ria composta
   nomeDep varchar(40),
   dataNasc date,
   parentesco varchar(45)
);
-- Inser√ß√£o de dependentes
insert into Dependente values
   (1000, 1, 'Ana', '2012-10-01','filha'),
   (1000, 2, 'Paulo', '1984-03-05', 'marido'),
   (1001, 1, 'Ant√¥nio', '1968-09-06', 'pai'),
   (1002, 1, 'Clara', '2014-06-01', 'irm√£'),
   (1004, 1, 'Vit√≥rio', '1994-06-01', 'irm√£o');
   
insert into Dependente values
   (1002, 2, 'Gema', '2014-06-01', 'irm√£');
   
insert into Dependente values
   (1002, 4, 'Casca', '2014-06-01', 'irm√£');

select * from funcionario;
-- Exibe a tabela Dependente
select * from Dependente;

-- Exibe os funcion√°rios e seus dependentes
select * from funcionario
inner join dependente on fkFunc = idFunc; 

-- Atualizar os dados de um dependente;
update Dependente set nomeDep='Paulo Jonas' where fkFunc=1000 and idDep = 2;

-- Inserir dados de um funcion√°rio sem supervisor.
insert into Funcionario values
    (null, 'Vivian','f',1100, '12345678779',null);

-- Exibir os dados dos funcion√°rios com e sem dependentes.
select * from funcionario left join dependente on fkFunc = idFunc;

-- Exibir os dados dos funcion√°rios sem dependentes.
select * from funcionario
left join dependente on fkFunc = idFunc
where fkFunc is null;

-- Exibir os dados dos funcion√°rios, seus respectivos supervisores e seus dependentes.
select * from funcionario as f
inner join funcionario as s on s.idFunc = f.fkSupervisor
inner join dependente on fkFunc = f.idFunc;

-- Exibir os dados dos funcion√°rios e seus respectivos supervisores, 
-- funcion√°rios sem supervisor, e seus respectivos dependentes.
select * from funcionario as f
left join funcionario as s on s.idFunc = f.fkSupervisor
inner join dependente on fkFunc = f.idFunc;


-- Criar o banco de dados ac3-seuNome (ac3-vivian);
CREATE DATABASE AC3LUIZHENRIQUE;

-- Selecionar o banco de dados criado;
USE AC3LUIZHENRIQUE;

 -- Criar as tabelas, configurar as chaves estrangeiras e inserir dados;
 CREATE TABLE Login (
idLogin INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45),
email VARCHAR (45),
senha VARCHAR (20)
);

CREATE TABLE Cadastro (
idCadastro INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45),
email VARCHAR (45) UNIQUE,
senha VARCHAR (20),
telefone CHAR (11),
dataNasc DATE,
fkLogin INT,
FOREIGN KEY (fkLogin) REFERENCES Login (idLogin)
);

CREATE TABLE Usuario (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
tipoDiabetes CHAR (1),
fkCadastro INT,
FOREIGN KEY (fkCadastro) REFERENCES Cadastro (idCadastro)
);

CREATE TABLE informacoes (
idInformacaoUsuario INT,
nomeUsuario VARCHAR (45),
emailUsuario VARCHAR (45),
senhaUsuario VARCHAR (20),
fkLogin INT,
FOREIGN KEY (fkLogin) REFERENCES Login (idLogin),
fkUsuario INT, 
FOREIGN KEY (fkUsuario) REFERENCES Usuario (idUsuario),
PRIMARY KEY (fkLogin, fkUsuario)
);

INSERT INTO Login VALUES 
(null, 'Larissa', 'Larissa@gmail.com', 'lari'),
(null, 'Pedro', 'Pedro@gmail.com', 'pedro'),
(null, 'Vivian', 'Vivian@gmail.com', 'vivian'),
(null, 'Julia', 'Julia@gmail.com', 'julia');

INSERT INTO Cadastro VALUES 
(null, 'Larissa', 'Larissa@gmail.com', 'lari','11974385921','2001-06-11',1),
(null, 'Pedro', 'Pedro@gmail.com', 'pedro','11965974592','2012-04-14',2),
(null, 'Vivian', 'Vivian@gmail.com', 'vivian','11957435967','2021-01-03',3),
(null, 'Julia', 'Julia@gmail.com', 'julia','11948349321','2020-10-21',4);

INSERT INTO Usuario VALUES
(null,'1',1),
(null,'2',2),
(null,'3',3),
(null,'4',4);

INSERT INTO Informacoes VALUES 
(1,'Larissa','Larissa@gmail.com','lari',1,1),
(2,'Pedro','Pedro@gmail.com','pedro',2,2),
(3,'Vivian','Vivian@gmail.com','vivian',3,3),
(4,'Julia','Julia@gmail.com','julia',4,4);

-- Exibir os dados das tabelas criadas separadamente;
SELECT * FROM Login;
SELECT * FROM Cadastro;
SELECT * FROM Usuario;
SELECT * FROM informacoes;


Refor√ßo 08/06
    
    create database LuizHenriqueFilme;
use LuizHenriqueFilme;

create table Filmes (
idFilmes int auto_increment,
nomeFilme varchar (45),
genero varchar (45),
fkDiretores int,
primary key (idFilmes, fkDiretores)
)auto_increment=1000;

create table Diretores (
idDiretores int primary key auto_increment,
nomeDiretor varchar (45),
Pa√≠s varchar (45),
dataNasc date
);

create table Atores (
idAtores int primary key,
nomeAtor varchar (45)
)auto_increment=100;


create table Filmes_Atores (
fkFilmes int,
fkAtores int,
nomePersonagem varchar (45),
ganhoAtor float,
primary key (fkFilmes, fkAtores),
foreign key (fkFilmes) references Filmes (idFilmes),
foreign key (fkAtores) references Atores (idAtores)
);

ALTER TABLE Filmes 
ADD foreign key (fkDiretores) references Diretores (idDiretores);

insert into Filmes values 
(null,'Invoca√ß√£o do Mal 3','Terror',1),
(null,'Megatubar√£o','Suspense',2);

insert into Diretores values 
(null, 'Jason', 'Estados Unidos', 1979-01-14),
(null, 'Gil','Brasil','1890-03-03');


[21:51, 17/06/2021] ùï∑ùñöùñéùñü ùï≥ùñäùñìùñóùñéùññùñöùñä ùï∫ùñëùñéùñõùñäùñéùñóùñÜ ‚ô•Ô∏è: UPDATE nome da tabela SET nome do campo = 'o que voc√™ quer mudar' WHERE id da tabela  = n√∫mero ou campo;
[21:54, 17/06/2021] ùï∑ùñöùñéùñü ùï≥ùñäùñìùñóùñéùññùñöùñä ùï∫ùñëùñéùñõùñäùñéùñóùñÜ ‚ô•Ô∏è: DELETE FROM nome da tabela WHERE Id da tabela = n√∫mero ou campo;
[22:10, 17/06/2021] ùï∑ùñöùñéùñü ùï≥ùñäùñìùñóùñéùññùñöùñä ùï∫ùñëùñéùñõùñäùñéùñóùñÜ ‚ô•Ô∏è: INNER JOIN:

SELECT * FROM funcionario (nome da tabela) INNER JOIN dependente (nome da tabela secund√°ria) on  fkFunc (exemplo com fk)=  idFunc;
[22:10, 17/06/2021] ùï∑ùñöùñéùñü ùï≥ùñäùñìùñóùñéùññùñöùñä ùï∫ùñëùñéùñõùñäùñéùñóùñÜ ‚ô•Ô∏è: TIPOS DE SELECTS:

Todos os dados de todos os dispositivos do tipo Smartphone em ordem alfab√©tica do modelo:

SELECT * FROM dispositivo (nome da tabela) WHERE tipo (campo da tabela) = smartphone  (atributo da tabela tipo) ORDER BY modelo;

Listar apenas os nomes dos modelos que come√ßam com IP:

SELECT modelo  (campo da tabela) FROM dispositivo ( nome da tabela) WHERE modelo (nome dos modelos) LIKE 'IP%';
[22:12, 17/06/2021] ùï∑ùñöùñéùñü ùï≥ùñäùñìùñóùñéùññùñöùñä ùï∫ùñëùñéùñõùñäùñéùñóùñÜ ‚ô•Ô∏è: INSERT INTO Funcionario (nome da tabela) VALUES 
(null (auto increment), campo1,campo2),
(1, campo1,campo2);
[22:24, 17/06/2021] ùï∑ùñöùñéùñü ùï≥ùñäùñìùñóùñéùññùñöùñä ùï∫ùñëùñéùñõùñäùñéùñóùñÜ ‚ô•Ô∏è: CRIA√á√ÉO DAS TABELAS COM FOREIGN KEYS:

CREATE TABLE Login (
idLogin INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45),
email VARCHAR (45),
senha VARCHAR (20)
); 

CREATE TABLE Cadastro (
idCadastro INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45),
email VARCHAR (45) UNIQUE,
senha VARCHAR (20),
telefone CHAR (11),
dataNasc DATE,
fkLogin INT,
FOREIGN KEY (fkLogin) REFERENCES Login (idLogin)
);

CREATE TABLE Usuario (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
tipoDiabetes CHAR (1),
fkCadastro INT,
FOREIGN KEY (fkCadastro) REFERENCES Cadastro (idCadastro)
);

CREATE TABLE informacoes (
idInformacaoUsuario INT,
nomeUsuario VARCHAR (45),
emailUsuario VARCHAR (45),
senhaUsuario VARCHAR (20),
fkLogin INT,
FOREIGN KEY (fkLogin) REFERENCES Login (idLogin),
fkUsuario ‚Ä¶
[22:25, 17/06/2021] ùï∑ùñöùñéùñü ùï≥ùñäùñìùñóùñéùññùñöùñä ùï∫ùñëùñéùñõùñäùñéùñóùñÜ ‚ô•Ô∏è: ALTER TABLE Empresa MODIFY nomeEmpresa varchar(40);

ALTER TABLE NomeDaTabela MODIFY NomeDoCampo TipoDoCampo;

Exemplo: ALTER TABLE empresa MODIFY NomeEmpresa VARCHAR(50);
