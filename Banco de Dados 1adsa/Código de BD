CREATE DATABASE faculdade;
USE faculdade;

CREATE TABLE Empresa (
IDEmpresa int primary key auto_increment,
    nomeEmpresa varchar(50),
    responsavel varchar(50)
);

INSERT INTO Empresa values
(null, 'Fleury', 'Maria'),
(null, 'C6', 'Pedro'),
(null, 'TIVIT', 'Camila'),
(null, 'Safra', 'Natalia');

SELECT * FROM Empresa;

SELECT nomeEmpresa, responsavel FROM Empresa;

SELECT * FROM Empresa order by nomeEmpresa;

SELECT * FROM Empresa order by responsavel desc;

SELECT * FROM Empresa WHERE nomeEmpresa LIKE '%r%';

SELECT * FROM Empresa WHERE nomeEmpresa LIKE 'f%';

SELECT * FROM Empresa WHERE nomeEmpresa LIKE '%r_';

INSERT INTO Empresa VALUES (null,'C6','Paulo');

DELETE FROM Empresa where idEmpresa =3;

DROP TABLE Empresa;

INSERT INTO Empresa VALUES (null,'Bandtec','Vera');

ALTER TABLE Empresa MODIFY nomeEmpresa varchar(40);

ALTER TABLE NomeDaTabela MODIFY NomeDoCampo TipoDoCampo;

Exemplo: ALTER TABLE empresa MODIFY NomeEmpresa VARCHAR(50);

COMANDOS PARA CRIAR USUÁRIO E REALIZAR LOGIN MySQL Server CLI:

-- Entrar no prompt de comando/cmd
-- win + r, digitar cmd, pressionar ok

-- Entrar no diretório bin do MySQL Server: arquivo mysql.exe
-- cd C:\Program Files\MySQL\MySQL Server 8.0\bin

-- Entrar no MySQL Server com o usuário root
-- mysql -u root -p

-- Digitar a senha do usuário root

-- Criar usuário MySQL Server via linha de comando
CREATE USER 'consultor'@'localhost' IDENTIFIED BY 'urubu100';

-- Dar todas as permissões ao usuário criado
GRANT ALL ON *.* TO 'consultor'@'localhost';

-- Dar permissão de apenas consulta
GRANT SELECT, UPDATE ON *.* TO 'consultor'@'localhost';

-- Confirmar as permissões/privilégios
flush privileges;




SCRIPT TABELA AULA:

USE faculdade;

CREATE TABLE aula (
	idAula int primary key auto_increment,
    nomeAula varchar(75),
    tipo char(1),
    check (tipo = 'o' or tipo = 'h' or tipo = 'p'),
    dtAula date,
    mensagem varchar(100)
);

INSERT INTO aula values 
	(null, 'Apresentação da disciplina e primeiros conceitos',
		'o', '2021-02-04', 'Conhecendo Banco de Dados'),
    (null, 'Continuação de conceitos e primeiros comandos SQL',
		'o', '2021-02-11', 'O primeiro comando a gente nunca esquece');
    
SELECT * FROM aula;

INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Permissão de usuário e comandos gerais', 'p', 
    '2021-02-18', 'Sejam bem vindos!');




SCRIPT TABELA ALUNO ATUALIZADO:


-- Criar o banco de dados
CREATE DATABASE faculdade;
-- Selecionar o banco de dados
USE faculdade;

-- Criar tabela ALUNO - DDL
-- varchar e char
-- 01211XXX

CREATE TABLE aluno (
	ra char(8) primary key,
    nome varchar(100),
    email varchar(100),
    telefone varchar(25)
);

-- Exibir os dados da tabela aluno
-- * = todos os campos/colunas
SELECT * FROM aluno;
SELECT ra, nome, email, telefone from aluno;
SELECT ra, email, nome, telefone from aluno;

-- Inserir dados na tabela aluno
INSERT INTO aluno VALUES ('01211999', 'Vivian Silva',
	'vivian.silva@bandtec.com.br', '11-987654321');
    
-- Para inserir mais de um registro
INSERT INTO aluno VALUES 
	('01211XXX', 'Vivian Aluna',
    'vivian.aluna@bandtec.com.br', '11-987655555'),
    ('01211YYY', 'Vivian Monitora',
    'vivian.monitor@bandtec.com.br', '11-987651111');

-- Inserir dados de apenas alguns campos
INSERT INTO aluno (ra, nome, telefone) VALUES 
('01211025', 'Daniel Pederzini', '11-987652345');    

-- Exibir dados dos alunos
SELECT * FROM aluno;

-- Exibir dados do aluno com um respectivo nome
SELECT * FROM aluno where nome = 'Daniel Pederzini';

-- não sei o sobrenome do Daniel, o que fazer?
SELECT * FROM aluno where nome like 'Daniel%';
SELECT * FROM aluno where nome like '%Pederzini';
SELECT * FROM aluno where nome like '%i';

-- todos os alunos que a segunda letra do nome é 'a'
SELECT * FROM aluno where nome like '_a%';
SELECT * FROM aluno where nome like '%e_ %';

-- Exibir os dados cujo o nome é diferente de um respectivo nome
SELECT * FROM aluno where nome <> 'Vivian Silva';
SELECT * FROM aluno where nome != 'Vivian Aluna';

SELECT * FROM aluno where nome like '%n %';

-- Exibir os campos ra, nome e email da tabela aluno
SELECT ra, nome, email from aluno;

-- Atualizar o e-mail de um respectivo aluno
UPDATE aluno SET email = 'daniel@uol.com.br' 
	WHERE ra = '01211025';

-- Atualizar o nome de um respectivo aluno
UPDATE aluno SET nome = 'Vivian Monitora' 
	WHERE ra = '01211XXX';

-- Ordenar em ordem descrecente pelo nome dos alunos
select * from aluno order by nome desc;

-- Deletar a tabela aluno
-- DROP TABLE aluno;  

-- Bons estudos!


SCRIPT BANCO DE DADOS FACULDADE - TABELA ALUNO:

-- Criar o banco de dados
CREATE DATABASE faculdade;
-- Selecionar o banco de dados
USE faculdade;

-- Criar tabela ALUNO - DDL
-- varchar e char
-- 01211XXX

CREATE TABLE aluno (
	ra char(8) primary key,
    nome varchar(100),
    email varchar(100),
    telefone varchar(25)
);

-- Exibir os dados da tabela aluno
-- * = todos os campos/colunas
SELECT * FROM aluno;

-- Inserir dados na tabela aluno
INSERT INTO aluno VALUES ('01211999', 'Vivian Silva',
	'vivian.silva@bandtec.com.br', '11-987654321');
    
-- Para inserir mais de um registro
INSERT INTO aluno VALUES 
	('01211XXX', 'Vivian Aluna','vivian.aluna@bandtec.com.br', '11-987655555'),
    ('01211YYY', 'Vivian Monitora','vivian.monitor@bandtec.com.br', '11-987651111');
    
    
    
    CREATE DATABASE TECCHICKEN;
USE TECCHICKEN;

CREATE TABLE Usuario (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
nome CHAR (50),
CPF VARCHAR (11),
nomeGranja VARCHAR(50),
CNPJ CHAR (14)
);

CREATE DATABASE TECCHICKEN;
USE TECCHICKEN;

CREATE TABLE Usuario (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
nome CHAR (50),
CPF VARCHAR (11),
nomeGranja VARCHAR(50),
CNPJ CHAR (14)
);

USUÁRIOS NO MySQL:
ALUNO: SELECT
PROFESSOR: SELECT, INSERT, DELETE, UPDATE
    
    
create database sprint1;
use faculdade;

CREATE TABLE Atleta (
	IDatleta int primary key auto_increment,
    nome varchar(40),
    modalidade varchar(40),
    qtdMedalha int 
);

INSERT INTO Atleta values 
(null, 'Usain Bolt', 'corrida', 8),
(null, 'Oscar Schmidt', 'basquete', 6),
(null, 'Lucas Bittencourt', 'Ginastica', 4),
(null, 'Maybyner Hilário', 'basquete', 5),
(null, 'Arthur Zanetti', 'Ginastica', 6),
(null, 'Frank Caldeira', 'corrida', 2);

SELECT * FROM Atleta; 


SELECT nome, qtdMedalha FROM Atleta; 


SELECT * FROM Atleta where modalidade= 'corrida';


SELECT * FROM Atleta order by modalidade;


SELECT * FROM Atleta order by qtdMedalha desc;


SELECT * FROM Atleta where nome like '%s%';


SELECT * FROM Atleta where nome like 'u%';


SELECT * FROM Atleta where nome like '%o';


SELECT * FROM Atleta where nome like '%r_';


DROP TABLE Atleta;


create database sprint2;
use faculdade;

CREATE TABLE Musica (
	IDmusica int primary key auto_increment,
    titulo varchar(40),
    artista varchar(40),
    genero varchar (40)
);

INSERT INTO Musica values
(null, 'Vt ta na bota', 'Mc Paulin da Capital','Funk'),
(null, 'So gratidao', 'Mc Paulin da Capital', 'Funk'),
(null, 'I am you', 'Ynw Melly', 'Trap'),
(null, 'Murder on my mind', 'Ynw Melly','Trap'),
(null, 'Know My Name', 'Fetty Wap', 'Rap'),
(null, 'Couple Bands', 'Fetty Wap', 'Rap'),
(null, 'Lancinho', 'Turma do Pagode', 'Pagode'),
(null, 'Cobertor de Orelha', 'Turma do Pagode', 'Pagode');


SELECT * FROM Musica;


SELECT titulo, artista FROM Musica;


SELECT * FROM Musica where genero= 'Funk';


SELECT * FROM Musica where artista='Ynw Melly';


SELECT * FROM Musica order by titulo;


SELECT * FROM Musica order by artista desc;


SELECT * FROM Musica where titulo like '%i%';


SELECT * FROM Musica where artista like 'y%';


SELECT * FROM Musica where genero like '_r%';


SELECT * FROM Musica where titulo like '%h_';


DROP TABLE Musica;
    
    
CREATE DATABASE TECCHICKEN;
USE TECCHICKEN;

CREATE TABLE Usuario (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
nome CHAR (50),
CPF VARCHAR (11),
nomeGranja VARCHAR (50),
CNPJ CHAR (14)
);

INSERT INTO Usuario VALUES 
(null, 'henrique', '85170656033', 'granja do henrique', '79838569000180'),
(null, 'luciano', '94997759007', 'granja do luciano', '39175355000157'),
(null, 'bia', '83261392037', 'granja da bia', '16398022000191'),
(null, 'tiago', '56849110055', 'granja do tiago', '22575602000100');

SELECT * FROM Usuario;

SELECT nome,  CNPJ FROM Usuario;

SELECT * FROM Usuario WHERE nomeGranja= 'granja da bia';

SELECT * FROM Usuario ORDER BY nomeGranja;

SELECT * FROM Usuario ORDER BY CNPJ DESC;

SELECT * FROM Usuario WHERE nome LIKE '%i%';

SELECT * FROM Usuario WHERE nome LIKE 'b%';

SELECT * FROM Usuario WHERE nome LIKE '%o';

SELECT * FROM Usuario WHERE nome LIKE '%n_';

DROP TABLE Usuario;
   
    
    
    Tabela  da prova:
    
    
    CREATE DATABASE ac01211089;
USE ac01211089;

CREATE TABLE Moto (
iDmoto int primary key auto_increment,
    nome varchar(50),
    placa varchar(7),
    cidade char (30)
);

INSERT INTO Moto values
(null, 'xj6 2020', 'FXZ4853', 'sao paulo'),
(null, 'honda cb 600f hornet','LRK0828','rio de janeiro'),
(null, 'bmw S1000RR', 'MOR1703', 'paraiba'),
(null, 'Honda CBR1000 RR', 'HCM4339', 'minas gerais' ),
(null, 'Yamaha YZF-R1', 'NAD5031', 'acre' ),
(null, 'bmw r 1200 gs', 'JOK9668','bahia' ),
(null, 'kawasaki zx-10r','NDF4741','roraima');

SELECT * FROM Moto;

SELECT nome, cidade FROM Moto;

SELECT * FROM Moto where cidade= 'sao paulo';

SELECT * FROM Moto where placa= 'NDF4741';

SELECT * FROM Moto order by cidade;

SELECT * FROM Moto order by nome desc;


SELECT * FROM Moto where nome like '%r_';

SELECT * FROM Moto where cidade like 's%';

SELECT * FROM Moto where placa like '_o%';

SELECT * FROM Moto where nome like '%j%';

UPDATE Moto set placa = 'LRK0828' where iDmoto = 'KEV6403';
SELECT * FROM Moto;

DELETE FROM Moto where idMoto =5;
SELECT * FROM Moto;

DROP TABLE Moto;




CREATE DATABASE Temperatura;
USE Temperatura;

CREATE TABLE Temperatura (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
temperatura CHAR (2),
dia DATE,
hora time
);

INSERT INTO Temperatura VALUES 
(null, '41', '2020-10-21', '12:00:22'),
(null, '21', '2021-01-03', '17:05:50'),
(null, '23', '2012-04-14', '10:30:23'),
(null, '32', '2001-06-11', '14:52:20');


SELECT * FROM Temperatura;

SELECT temperatura, hora FROM Temperatura;

SELECT * FROM Temperatura WHERE dia= '2001-06-11';

SELECT * FROM Temperatura ORDER BY dia;

SELECT * FROM Temperatura ORDER BY hora DESC;

SELECT * FROM Temperatura WHERE temperatura LIKE '%23%';

SELECT * FROM Temperatura WHERE dia LIKE '2021-01-03%';

SELECT * FROM Temperatura WHERE hora LIKE '%12:00:22';

SELECT * FROM Temperatura WHERE temperatura LIKE '32%';

DROP TABLE Temperatura;



-- Criar database Jornal
create database Jornal;

-- Usar Jornal
use jornal;

-- Criar tabela Jornal

create table Jornal (
idJornal int primary key auto_increment,
nomeJornal varchar (45)
);

-- Criar tabela Reporter

create table Reporter (
idReporter int primary key,
nomeReporter varchar (45),
dataNasc date,
sexo char (1),
check (sexo='m'or sexo='f'),
fkJornal int,
foreign key (fkJornal) references Jornal (idJornal)
);

-- Inserir dados na Tabela Jornal

insert into Jornal values 
(null,'Estadao');
-- Inserir dados na Tabela Reporter
insert into Reporter values
(1,'Mateus','1996-06-12','m', 1),
(2,'Larissa','2000-07-13','f', 2);

-- Selecionar todos os dados das tabelas

select * from Jornal;

select * from Reporter;

Update Jornal set nomeJornal='Datafolha' Where idJornal=1;

Delete from Jornal Where idJornal=1;

SCRIPT DO REFORÇO

-- Criando banco de dados
CREATE DATABASE Produtos;

-- Usando banco de dados
USE Produtos;

-- Criando tabela Categoria
CREATE TABLE Categoria (
idCategoria INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45)
);

-- Criando tabela Produtos
CREATE TABLE Produtos (
idProduto INT PRIMARY KEY AUTO_INCREMENT,
descricao VARCHAR (100),
marca VARCHAR (50),
fkCategoria INT,
FOREIGN KEY (fkCategoria) REFERENCES Categoria (idCategoria)
)AUTO_INCREMENT = 100; 

-- Criando tabela Loja
CREATE TABLE Loja (
idLoja INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45),
DataFunc DATE
)AUTO_INCREMENT = 1000;

-- Criando tabela associativa
CREATE TABLE ProdutoLoja (
fkProduto INT,
FOREIGN KEY (fkProduto) REFERENCES Produtos (idProduto),
fkLoja INT, 
FOREIGN KEY (fkLoja) REFERENCES Loja (idLoja),
PRIMARY KEY (fkProduto, fkLoja),
preco DECIMAL (6,2)
);

 -- Inserindo dados na tabela categoria
INSERT INTO Categoria	(nome)
VALUES 					('Chocolate'),
						('Refrigerante');

-- Inserindo dados na tabela produtos
INSERT INTO Produtos	(descricao, marca, fkCategoria)
VALUES					('Sensação', 'Lacta', 1),
						('Diamante negro', 'Nestle', 1),
                        ('Talento', 'Garoto', 1),
                        ('Coca-cola', 'Coca', 2),
                        ('Fanta uva', 'Fanta', 2),
                        ('Sprit limão', 'Sprit', 2);

-- Inserindo dados na tabela loja 
INSERT INTO Loja		(nome, dataFunc)
VALUES					('Loja 1', '2000-01-01'),
						('Loja 2', '2001-12-12');

-- Inserindo dados na tabela ProdutoLoja
INSERT INTO ProdutoLoja	(fkProduto, fkLoja, preco)
VALUES					(100, 1000, 5.00),
						(101, 1000, 6.50),
                        (102, 1000, 4.00),
                        (104, 1000, 7.90),
                        (100, 1001, 6.50),
                        (101, 1001, 5.80),
                        (103, 1001, 4.60),
                        (105, 1001, 6.80);

-- Exibindo as tabelas separadamente
SELECT * FROM Categoria;
SELECT * FROM Produtos;
SELECT * FROM Loja;
SELECT * FROM ProdutoLoja;

-- Exibindo dados das categorias e dos seus produtos
SELECT Categoria.*, idProduto, descricao, marca FROM Categoria
INNER JOIN Produtos
ON	idCategoria = fkCategoria;

-- 	Exibindo dados de uma derterminada categoria e os dados dos seus produtos
SELECT Categoria.*, idProduto, descricao, marca FROM Categoria
INNER JOIN Produtos
ON	idCategoria = fkCategoria
WHERE idCategoria = 1;

-- Exibindo a média e as somas dos produtos em geral
SELECT  ROUND(AVG(preco), 2) AS `Média dos preços`,
		SUM(preco) AS `Soma dos preços` FROM ProdutoLoja; 
        
-- Exibindo o menor e o maior preço dos produtos em geral
SELECT 	MAX(preco) AS `Maior preço`,
		MIN(preco) AS `Menor preço` FROM ProdutoLoja;
        
-- Exibindo os dados de um determinado produto, os dados das lojas que o vendem e seu preço em cada loja
SELECT idProduto, descricao, marca, idLoja, nome, dataFunc, preco FROM 	ProdutoLoja
INNER JOIN Produtos
ON fkProduto = idProduto
INNER JOIN Loja 
ON fkLoja = idLoja
WHERE idProduto = 101;

-- Exibindo os dados dos produtos, os dados das categorias correspondentes, os dados das lojas correspondentes e os preços dos produtos em cada loja
SELECT idProduto, descricao, marca, idCategoria, Categoria.nome, idLoja, Loja.nome, dataFunc, preco FROM 	ProdutoLoja
INNER JOIN Produtos
ON fkProduto = idProduto
INNER JOIN Categoria
ON fkCategoria = idCategoria
INNER JOIN Loja 
ON fkLoja = idLoja;

-- Exibindo a identificação do produto, a média e a soma dos preços dos produtos, agrupadas por produto
SELECT fkProduto, ROUND(AVG(preco), 2) AS `Média dos preços`,
SUM(preco) AS `Soma de preços`	FROM ProdutoLoja GROUP BY fkProduto;	
                    
                    
-- Exibindo a identificação da loja, a média e a soma dos preços dos produtos, agrupadas por loja
SELECT fkLoja, ROUND(AVG(preco), 2) AS `Média dos preços`,
SUM(preco)	AS `Soma de preços` FROM ProdutoLoja GROUP BY fkLoja;

-- Exibindo a identificação do produto, o menor e o maior preço, agrupado por produto
SELECT fkProduto, MIN(preco) AS `Menor preço`,
MAX(preco) AS `Maior preço`	FROM ProdutoLoja GROUP BY fkProduto;
                    
-- Exibir a identificação da loja, o menor e o maior preço, agrupado por loja
SELECT fkLoja, MIN(preco) AS `Menor preço`,
MAX(preco) AS `Maior preço`	FROM ProdutoLoja GROUP BY fkLoja;
MAX(preco) AS `Maior preço`	FROM ProdutoLoja GROUP BY fkLoja;

SELECT * FROM categoria;
SELECT * FROM produtos;

INSERT INTO categoria VALUES
(null,'eletrônico');
 
SELECT * FROM categoria LEFT JOIN produtos ON idCategoria = fkCategoria;
SELECT * FROM categoria INNER JOIN produtos ON idCategoria = fkCategoria;
SELECT * FROM categoria RIGHT JOIN produtos 
    ON idCategoria = fkCategoria 
    WHERE fkCategoria is not null;
SELECT * FROM categoria RIGHT JOIN produtos 
    ON idCategoria = fkCategoria 
    WHERE fkCategoria is null;

INSERT INTO produtos VALUES
(null,'Smartphome','Samsung',null);
 
/*
-- Criando banco de dados
CREATE DATABASE Produtos;

-- Usando banco de dados
USE Produtos;

-- Criando tabela Categoria
CREATE TABLE Categoria (
	idCategoria	INT PRIMARY KEY AUTO_INCREMENT,
    nome		VARCHAR(45)
);

-- Criando tabela Produtos
CREATE TABLE Produtos (
	idProduto	INT PRIMARY KEY AUTO_INCREMENT,
    descricao	VARCHAR(100),
	marca		VARCHAR(50),
    fkCategoria	INT,
    FOREIGN KEY (fkCategoria) REFERENCES Categoria (idCategoria)
)AUTO_INCREMENT = 100;

-- Criando tabela Loja
CREATE TABLE Loja (
	idLoja		INT PRIMARY KEY AUTO_INCREMENT,
    nome		VARCHAR(45),
    dataFunc	DATE 
)AUTO_INCREMENT = 1000;

-- Criando tabela associativa
CREATE TABLE ProdutoLoja (
	fkProduto	INT,
    FOREIGN KEY (fkProduto) REFERENCES Produtos (idProduto),
    fkLoja		INT,
    FOREIGN KEY (fkLoja) REFERENCES Loja (idLoja),
    PRIMARY KEY (fkProduto, fkLoja),
    preco		DECIMAL(6,1)
);

-- Inserindo dados na tabela categoria
INSERT INTO Categoria	(nome)
VALUES 					('Chocolate'),
						('Refrigerante');
                    
-- Inserindo dados na tabela produtos
INSERT INTO Produtos	(descricao, marca, fkCategoria)
VALUES					('Sensação', 'Lacta', 1),
						('Diamante negro', 'Nestle', 1),
                        ('Talento', 'Garoto', 1),
                        ('Coca-cola', 'Coca', 2),
                        ('Fanta uva', 'Fanta', 2),
                        ('Sprit limão', 'Sprit', 2);
                        
-- Inserindo dados na tabela loja 
INSERT INTO Loja		(nome, dataFunc)
VALUES					('Loja 1', '2000-01-01'),
						('Loja 2', '2001-12-12');

-- Inserindo dados na tabela ProdutoLoja
INSERT INTO ProdutoLoja	(fkProduto, fkLoja, preco)
VALUES					(100, 1000, 5.00),
						(101, 1000, 6.50),
                        (102, 1000, 4.00),
                        (104, 1000, 7.90),
                        (100, 1001, 6.50),
                        (101, 1001, 5.80),
                        (103, 1001, 4.60),
                        (105, 1001, 6.80);

-- Exibindo as tabelas separadamente
SELECT * FROM Categoria;
SELECT * FROM Produtos;
SELECT * FROM Loja;
SELECT * FROM ProdutoLoja;

-- Exibindo dados das categorias e dos seus produtos
SELECT Categoria.*, idProduto, descricao, marca FROM 	Categoria
INNER JOIN		Produtos
ON				idCategoria = fkCategoria;

-- 	Exibindo dados de uma derterminada categoria e os dados dos seus produtos
SELECT Categoria.*, idProduto, descricao, marca FROM 	Categoria
INNER JOIN 		Produtos
ON				idCategoria = fkCategoria
WHERE			idCategoria = 1;

-- Exibindo a média e as somas dos produtos em geral
SELECT  ROUND(AVG(preco), 2) AS `Média dos preços`,
		SUM(preco) AS `Soma dos preços` FROM ProdutoLoja; 
        
-- Exibindo o menor e o maior preço dos produtos em geral
SELECT 	MAX(preco) AS `Maior preço`,
		MIN(preco) AS `Menor preço` FROM ProdutoLoja;
        
-- Exibindo os dados de um determinado produto, os dados das lojas que o vendem e seu preço em cada loja
SELECT idProduto, descricao, marca, idLoja, nome, dataFunc, preco FROM 	ProdutoLoja
INNER JOIN 		Produtos
ON				fkProduto = idProduto
INNER JOIN		Loja 
ON 				fkLoja = idLoja
WHERE 			idProduto = 101;

-- Exibindo os dados dos produtos, os dados das categorias correspondentes, os dados das lojas correspondentes e os preços dos produtos em cada loja
SELECT idProduto, descricao, marca, idCategoria, Categoria.nome, idLoja, Loja.nome, dataFunc, preco FROM 	ProdutoLoja
INNER JOIN 		Produtos
ON				fkProduto = idProduto
INNER JOIN		Categoria
ON				fkCategoria = idCategoria
INNER JOIN		Loja 
ON 				fkLoja = idLoja;

-- Exibindo a identificação do produto, a média e a soma dos preços dos produtos, agrupadas por produto
SELECT fkProduto, 	ROUND(AVG(preco), 2) AS `Média dos preços`,
					SUM(preco) AS `Soma de preços`	FROM ProdutoLoja GROUP BY fkProduto;	
                    
                    
-- Exibindo a identificação da loja, a média e a soma dos preços dos produtos, agrupadas por loja
SELECT fkLoja, 	ROUND(AVG(preco), 2) AS `Média dos preços`,
				SUM(preco)	AS `Soma de preços` FROM ProdutoLoja GROUP BY fkLoja;

-- Exibindo a identificação do produto, o menor e o maior preço, agrupado por produto
SELECT fkProduto, 	MIN(preco) AS `Menor preço`,
					MAX(preco) AS `Maior preço`	FROM ProdutoLoja GROUP BY fkProduto;
                    
-- Exibir a identificação da loja, o menor e o maior preço, agrupado por loja
SELECT fkLoja, 	MIN(preco) AS `Menor preço`,
				MAX(preco) AS `Maior preço`	FROM ProdutoLoja GROUP BY fkLoja;


SCRIPT PROVA:

create database caseFuncionario;
use caseFuncionario;

create table Funcionario (
   idFunc int primary key auto_increment,
   nome varchar(40),
   genero char(1),
   check (genero = 'm' or genero ='f' or genero = 'n'),
   -- no MySQL, versões anteriores a 8.0.16, devem usar enum no lugar do check:
   -- genero enum('m','f','n'),
   salario double, -- decimal(7,2) 7 significa que o número tem 7 digitos, considerando os digitos antes da 
                         -- virgula e os depois
                         -- 2 significa que tem 2 diginos após a vírgula
                         -- decimal(7,2) significa um número do tipo 99999,99
   check (salario > 0),  -- isso não funciona em versões anteriores a 8.0.16 do MySQL
                         -- se fosse nota: check (nota >= 0 and nota <= 10)
   cpf char(11) unique,
   fkSupervisor int,  -- implementação de um relacionamento recursivo um para muitos
   foreign key(fkSupervisor) references Funcionario(idFunc)
) auto_increment = 1000;

select * from Funcionario;
desc Funcionario;

-- o comando a seguir não funciona pois está tentando inserir 'x' para genero
/*insert into Funcionario values
    (null, 'Maria Aparecida','x',15000,'15915998788', null);
*/
-- inserção de um funcionário, que não tem supervisor    
insert into Funcionario values
    (null, 'Maria Aparecida','f',15000, '15915998788',null);

-- Inserir o mesmo cpf - unique - Este comando dará erro
insert into Funcionario values
    (null, 'Maria Desaparecida','f', 15000, '15915998788', null);
    
insert into Funcionario values
    (null, 'Vitória','f', 50000, '15915915877', 1000);
    
update funcionario set fkSupervisor = 1004 where idFunc = 1000;
    
-- inserção de mais um funcionário (supervisor deste funcionário será a Maria Aparecida - id 1000)    
insert into Funcionario values
	(null, 'José da Silva','m',5000,'12345678999', 1000);
-- inserção de mais um funcionário (supervisor deste funcionário será o José da Silva - id 1001)
insert into Funcionario values
    (null, 'João Oliveira','m', 2000,'65498788844',1001);

-- Exibir os dados dos funcionários e dos supervisores
-- correspondentes
-- se existissem 2 tabelas, uma Funcionario e outra Supervisor, ficaria assim o comando:
-- select * from funcionario join supervisor on fksupervisor = idfunc;
-- mas como a tabela é a mesma, tanto de Funcionario como de Supervisor, então o certo é:
select * from funcionario as func join funcionario as supervisor 
													on func.fksupervisor = supervisor.idfunc;
                                                    
select func.nome as NomeFunc, supervisor.nome as Supervisor 
				from funcionario as func join funcionario as supervisor 
								on func.fksupervisor = supervisor.idfunc;
        
-- Parei aqui!!

-- Criação da tabela Dependente, que é uma entidade fraca em relação a Funcionario 
create table Dependente (
   fkFunc int,
   foreign key (fkFunc) references Funcionario(idFunc),
   idDep int,
   primary key (fkFunc, idDep),  -- chave primária composta
   nomeDep varchar(40),
   dataNasc date,
   parentesco varchar(45)
);
-- Inserção de dependentes
insert into Dependente values
   (1000, 1, 'Ana', '2012-10-01','filha'),
   (1000, 2, 'Paulo', '1984-03-05', 'marido'),
   (1001, 1, 'Antônio', '1968-09-06', 'pai'),
   (1002, 1, 'Clara', '2014-06-01', 'irmã'),
   (1004, 1, 'Vitório', '1994-06-01', 'irmão');
   
insert into Dependente values
   (1002, 2, 'Gema', '2014-06-01', 'irmã');
   
insert into Dependente values
   (1002, 4, 'Casca', '2014-06-01', 'irmã');

select * from funcionario;
-- Exibe a tabela Dependente
select * from Dependente;

-- Exibe os funcionários e seus dependentes
select * from funcionario
inner join dependente on fkFunc = idFunc; 

-- Atualizar os dados de um dependente;
update Dependente set nomeDep='Paulo Jonas' where fkFunc=1000 and idDep = 2;

-- Inserir dados de um funcionário sem supervisor.
insert into Funcionario values
    (null, 'Vivian','f',1100, '12345678779',null);

-- Exibir os dados dos funcionários com e sem dependentes.
select * from funcionario left join dependente on fkFunc = idFunc;

-- Exibir os dados dos funcionários sem dependentes.
select * from funcionario
left join dependente on fkFunc = idFunc
where fkFunc is null;

-- Exibir os dados dos funcionários, seus respectivos supervisores e seus dependentes.
select * from funcionario as f
inner join funcionario as s on s.idFunc = f.fkSupervisor
inner join dependente on fkFunc = f.idFunc;

-- Exibir os dados dos funcionários e seus respectivos supervisores, 
-- funcionários sem supervisor, e seus respectivos dependentes.
select * from funcionario as f
left join funcionario as s on s.idFunc = f.fkSupervisor
inner join dependente on fkFunc = f.idFunc;

SEGUNDA OPÇÃO: 

-- LUIZ HENRIQUE OLIVEIRA NARDI RA: 01211089
CREATE DATABASE Exercicio11;
USE Exercicio11;

-- TABELA DEPARTAMENTO
CREATE TABLE Departamento (
idDepto INT PRIMARY KEY,
nomeDepto VARCHAR (40),
fkGerente INT,
dataInicioGer DATE
);

-- TABELA FUNCIONARIO
CREATE TABLE Funcionario (
idFunc INT PRIMARY KEY,
nomeFunc VARCHAR (30),
salario FLOAT,
CHECK (salario > 0),
sexo CHAR (1),
CHECK (sexo = 'm' OR sexo = 'f'),
fkSupervisor INT,
dataNasc DATE,
fkDepto INT,
FOREIGN KEY (fkDepto) REFERENCES Departamento (idDepto)
);

-- TABELA PROJETO
CREATE TABLE Projeto (
idProj INT PRIMARY KEY,
nomeProj VARCHAR (90),
localProj VARCHAR (80),
fkDepto INT,
FOREIGN KEY (fkDepto) REFERENCES Departamento (idDepto)
);

-- TABELA FUNCPROJ
CREATE TABLE FuncProj (
fkFunc INT,
fkProj INT,
PRIMARY KEY (fkFunc, fkProj),
horas DECIMAL (3,1),
FOREIGN KEY (fkFunc) REFERENCES Funcionario (idFunc),
FOREIGN KEY (fkProj) REFERENCES Projeto (idProj)
);

ALTER TABLE Departamento ADD FOREIGN KEY (fkGerente) REFERENCES Funcionario (idFunc);

INSERT INTO Departamento VALUES 
(105, 'Pesquisa', NULL, '2008-05-22'),
(104, 'Administração', NULL, '2015-01-01'),
(101, 'Matriz', NULL, '2001-06-19');

INSERT INTO Funcionario VALUES 
(1, 'João Silva', 3500, 'm', 2, '1985-01-09', 105),
(2, 'Fernando Wong', 4500, 'm', 8, '1975-12-08', 105),
(3, 'Alice Sousa', 2500, 'f', 7, '1988-01-09', 104),
(4, 'Janice Morais', 4300, 'f', 8, '1970-06-20', 104),
(5, 'Ronaldo Lima', 3800, 'm', 1, '1982-09-15', 105),
(6, 'Joice Leite', 2500, 'f', 1, '1992-01-09', 105),
(7, 'Antonio Pereira', 2500, 'm', 4, '1989-03-29', 104),
(8, 'Juliano Brito', 5500, 'm', NULL, '1957-11-10', 101);

INSERT INTO Projeto VALUES 
(1, 'Produto X', 'Santo André', 105),
(2, 'Produto Y', 'Itu', 105),
(3, 'Produto Z', 'São Paulo', 105),
(10, 'Informatização', 'Mauá', 104),
(20, 'Reorganização', 'São Paulo', 101),
(30, 'Beneficios', 'Mauá', 104);

INSERT INTO FuncProj VALUES 
(1, 1, 32.5),
(1, 2, 7.5),
(5, 3, 40.0),
(6, 1, 20.0),
(6, 2, 20.0),
(2, 2, 10.0),
(2, 3, 10.0),
(2, 10, 10.0),
(2, 20, 10.0),
(3, 30, 30.0),
(3, 10, 10.0),
(7, 10, 35.0),
(7, 30, 5.0),
(4, 30, 20.0),
(4, 20, 15.0),
(8, 20, NULL);

UPDATE Departamento SET fkGerente = 2 WHERE idDepto = 105;

UPDATE Departamento SET fkGerente = 7 WHERE idDepto = 104;

UPDATE Departamento SET fkGerente = 8 WHERE idDepto = 101;

SELECT * FROM Departamento;

SELECT * FROM Funcionario;

SELECT * FROM Projeto;

SELECT * FROM FuncProj;

-- INFELIZMENTE NÃO VAI DAR CERTO, POIS O IDFUNC NÃO PODE SER NULO.
INSERT INTO Funcionario VALUES
(null, "Cecilia Ribeiro", 2800, "f", null, "1980-04-05", 104);

-- NÃO VAI DAR CERTO, O ID 3 ESTÁ DUPLICADO.
INSERT INTO Funcionario VALUES
(3, "Alice Souza", 2800, "f", 4, "1980-04-05", 104);

-- NÃO VAI DAR CERTO, O FK 107 NÃO EXISTE.
INSERT INTO Funcionario VALUES 
(9, "Cecília Ribeiro", 2800, "f", 4, "1980-04-05", 107);

-- FUNCIONOUUUU ;)
INSERT INTO Funcionario VALUES
(9, "Cecília Ribeiro", 2800, "f", 4, "1980-04-05", 104);

-- FUNCIONOUUUU ;)
DELETE FROM FuncProj WHERE fkFunc = 3 AND fkProj = 10;

-- FUNCIONARIO ESTÁ ASSOCIADO A UM PROJETO.
DELETE FROM Funcionario WHERE idFunc = 4;

-- FUNCIONARIO ESTÁ ASSOCIADO A UM PROJETO.
DELETE FROM Funcionario WHERE idFunc = 2;

-- FUNCIONOUUUU ;)
UPDATE Funcionario SET salario = 2800 WHERE idFunc = 3;

-- FUNCIONOUUUU ;)
UPDATE Funcionario SET fkDepto = 101 WHERE idFunc = 3;

-- NÃO FUNCIONOU, POIS FK 107 NÃO EXISTE.
UPDATE Funcionario SET fkDepto = 107 WHERE idFunc = 3;

SELECT nomeFunc, dataNasc, salario FROM Funcionario WHERE nomeFunc = "João Silva";

SELECT DISTINCT salario FROM Funcionario;

SELECT salario FROM Funcionario ORDER BY nomeFunc;

SELECT * FROM Funcionario ORDER BY salario DESC;

SELECT * FROM Funcionario WHERE salario > 2000 AND salario < 4000;

SELECT nomeFunc, salario FROM Funcionario WHERE nomeFunc LIKE "j%";

SELECT nomeFunc, salario FROM Funcionario WHERE nomeFunc LIKE "%a";

SELECT nomeFunc, salario FROM Funcionario WHERE nomeFunc LIKE "__n%";

SELECT nomeFunc, dataNasc FROM Funcionario WHERE nomeFunc LIKE "%s____";

SELECT * FROM Funcionario INNER JOIN Departamento ON fkDepto = idDepto WHERE nomeDepto = "Pesquisa";

SELECT * FROM Funcionario INNER JOIN Departamento ON fkDepto = idDepto WHERE nomeDepto = "Pesquisa" AND salario > 3500;

SELECT * FROM Funcionario INNER JOIN Departamento ON fkDepto = idDepto WHERE nomeDepto = "Pesquisa" AND nomeFunc LIKE "J%";

SELECT Funcionario.idFunc AS Funcionario, Funcionario.nomeFunc AS NomeFuncionario, Supervisor.idFunc AS idSupervisor, Supervisor.nomeFunc AS NomeSupervisor
FROM Funcionario AS Funcionario
INNER JOIN Funcionario AS Supervisor
ON funcionario.fkSupervisor = Supervisor.idFunc;

SELECT Proj.idProj AS idProjeto, Proj.fkDepto AS 'Departamento' , Ger.nomeFunc AS Gerente, Ger.dataNasc AS 'Data Nascimento' FROM Projeto AS Proj
INNER JOIN Departamento ON fkDepto = idDepto INNER JOIN Funcionario AS Ger ON fkGerente = idFunc 
WHERE Proj.localProj = 'São Paulo';

SELECT Func.idFunc AS idFuncionario, Func.nomeFunc AS Funcionario, FuncProj.fkProj AS Projeto, Proj.nomeProj AS 'Nome Projeto', FuncProj.horas AS 'Quantidade de Horas' FROM FuncProj AS FuncProj
INNER JOIN Funcionario AS Func ON fkFunc = idFunc INNER JOIN Projeto AS Proj ON fkProj = idProj;

SELECT nomeFunc FROM Funcionario WHERE dataNasc < "1980-01-01";

SELECT count(DISTINCT(salario)) AS "Salários diferentes" FROM Funcionario;

SELECT count(DISTINCT(localProj)) AS "Locais diferentes" FROM Projeto;

SELECT TRUNCATE(AVG(salario),2) AS "Média salarial", TRUNCATE(sum(salario),2) AS "Soma dos salários" FROM Funcionario;

SELECT min(salario), max(salario) FROM Funcionario;

SELECT idDepto, TRUNCATE(AVG(salario),2) AS "Média salarial", TRUNCATE(sum(salario),2) AS "Soma dos salários" FROM Funcionario INNER JOIN Departamento ON idDepto = fkDepto GROUP BY idDepto;

SELECT idDepto, min(salario), max(salario) FROM Funcionario INNER JOIN Departamento ON idDepto = fkDepto GROUP BY idDepto;

INSERT INTO Funcionario VALUES 
(10, "José da Silva", 1800, "m", 3, "2000-10-12", NULL),
(11, "Benedito Almeida", 1200, "m", 5, "2001-09-01", NULL);

INSERT INTO Departamento VALUES 
(110, "RH", 3, "2018-11-10");


TERCEIRA OPÇÃO:

USE faculdade;

CREATE TABLE aula (
	idAula int primary key auto_increment,
    nomeAula varchar(75),
    tipo char(1),
    check (tipo = 'o' or tipo = 'h' or tipo = 'p'),
    dtAula date,
    mensagem varchar(100)
);

INSERT INTO aula values 
	(null, 'Apresentação da disciplina e primeiros conceitos',
		'o', '2021-02-04', 'Conhecendo Banco de Dados'),
    (null, 'Continuação de conceitos e primeiros comandos SQL',
		'o', '2021-02-11', 'O primeiro comando a gente nunca esquece');
    
SELECT * FROM aula;

INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Permissão de usuário e comandos gerais', 'p', 
    '2021-02-18', 'Sejam bem vindos!');
  
INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Linha de comando - CLI - MySQL Server Client', 'p', 
    '2021-02-25', 'Codando no client!');

    
INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Avaliaçao Continuada I', 'p', 
    '2021-03-04', 'Boa prova!');
    
INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Entregáveis de banco de dados', 'o', 
    '2021-03-11', 'Boa Sprint!');
    
INSERT INTO aula (nomeAula, tipo, dtAula, mensagem) values 
	('Chave estrangeira, Constraint e Aliases', 'o', 
    '2021-03-18', 'Agora complicou! =)');
    
-- Aula 07
SELECT * FROM aula;
select * from aluno;

-- criar a tabela chamada
CREATE TABLE chamada (
	idChamada int primary key auto_increment,
    fkAluno char(8), -- chave estrangeira referente a tabela aluno
    foreign key (fkAluno) references aluno(ra), -- configuração chave estrangeira fkAluno
    dtPresenca datetime default current_timestamp,
    presenca char(3),
    check (presenca = 'sim' or presenca = 'não'),
    fkAula int, -- chave estrangeira referente a tabela aula
    foreign key (fkAula) references aula(idAula) -- configuração chave estrangeira fkAula
) auto_increment=20000;

-- exibir os dados da tabela chamada;
select * from chamada;

-- inserir dados na tabela chamada;
insert into chamada (fkAluno, presenca, fkAula) values
	('01211999','sim',7);
insert into chamada (fkAluno, presenca, fkAula) values
	('01211025','sim',7);
    
-- exibir todos os dados da tabela chamada e o nome do aluno
select chamada.*, aluno.nome from aluno join chamada 
	on fkAluno = ra;
 
-- exibir todos os dados da tabela chamada e a mensagem da aula do dia 18/03.
select chamada.*, aula.mensagem from aula inner join chamada 
	on fkAula = idAula where dtAula = '2021-03-18';

-- AVANÇADO - JOIN ENTRE 3 TABELAS
select * from aluno join chamada on fkAluno = ra
	join aula on fkAula = idAula;
    
-- Bon estudos!
	use faculdade;
    select * from aula;
    
    start transaction;
    
    insert into aula (nomeAula, tipo, dtAula, mensagem) values
    ('Dicionário de Dados e Start Transaction', 'o',
    '2021-05-13','Só alegria!');
    
    select * from aula;
    rollback;
    
    select * from aula;
    
    
    
    QUARTA OPÇÃO:
    
    create database caseFuncionario;
use caseFuncionario;

create table Funcionario (
   idFunc int primary key auto_increment,
   nome varchar(40),
   genero char(1),
   check (genero = 'm' or genero ='f' or genero = 'n'),
   -- no MySQL, versões anteriores a 8.0.16, devem usar enum no lugar do check:
   -- genero enum('m','f','n'),
   salario double, -- decimal(7,2) 7 significa que o número tem 7 digitos, considerando os digitos antes da 
                         -- virgula e os depois
                         -- 2 significa que tem 2 diginos após a vírgula
                         -- decimal(7,2) significa um número do tipo 99999,99
   check (salario > 0),  -- isso não funciona em versões anteriores a 8.0.16 do MySQL
                         -- se fosse nota: check (nota >= 0 and nota <= 10)
   cpf char(11) unique,
   fkSupervisor int,  -- implementação de um relacionamento recursivo um para muitos
   foreign key(fkSupervisor) references Funcionario(idFunc)
) auto_increment = 1000;

select * from Funcionario;
desc Funcionario;

-- o comando a seguir não funciona pois está tentando inserir 'x' para genero
/*insert into Funcionario values
    (null, 'Maria Aparecida','x',15000,'15915998788', null);
*/
-- inserção de um funcionário, que não tem supervisor    
insert into Funcionario values
    (null, 'Maria Aparecida','f',15000, '15915998788',null);

-- Inserir o mesmo cpf - unique - Este comando dará erro
insert into Funcionario values
    (null, 'Maria Desaparecida','f', 15000, '15915998788', null);
    
-- inserção de mais um funcionário (supervisor deste funcionário será a Maria Aparecida - id 1000)    
insert into Funcionario values
	(null, 'José da Silva','m',5000,'12345678999', 1000);
-- inserção de mais um funcionário (supervisor deste funcionário será o José da Silva - id 1001)
insert into Funcionario values
    (null, 'João Oliveira','m', 2000,'65498788844',1001);

-- Exibir os dados dos funcionários e dos supervisores
-- correspondentes
-- se existissem 2 tabelas, uma Funcionario e outra Supervisor, ficaria assim o comando:
-- select * from funcionario join supervisor on fksupervisor = idfunc;
-- mas como a tabela é a mesma, tanto de Funcionario como de Supervisor, então o certo é:
select * from funcionario as func join funcionario as supervisor 
															on func.fksupervisor = supervisor.idfunc;
        
-- Parei aqui!!

create database caseFuncionario;
use caseFuncionario;

create table Funcionario (
   idFunc int primary key auto_increment,
   nome varchar(40),
   genero char(1),
   check (genero = 'm' or genero ='f' or genero = 'n'),
   -- no MySQL, versões anteriores a 8.0.16, devem usar enum no lugar do check:
   -- genero enum('m','f','n'),
   salario double, -- decimal(7,2) 7 significa que o número tem 7 digitos, considerando os digitos antes da 
                         -- virgula e os depois
                         -- 2 significa que tem 2 diginos após a vírgula
                         -- decimal(7,2) significa um número do tipo 99999,99
   check (salario > 0),  -- isso não funciona em versões anteriores a 8.0.16 do MySQL
                         -- se fosse nota: check (nota >= 0 and nota <= 10)
   cpf char(11) unique,
   fkSupervisor int,  -- implementação de um relacionamento recursivo um para muitos
   foreign key(fkSupervisor) references Funcionario(idFunc)
) auto_increment = 1000;

select * from Funcionario;
desc Funcionario;

-- o comando a seguir não funciona pois está tentando inserir 'x' para genero
/*insert into Funcionario values
    (null, 'Maria Aparecida','x',15000,'15915998788', null);
*/
-- inserção de um funcionário, que não tem supervisor    
insert into Funcionario values
    (null, 'Maria Aparecida','f',15000, '15915998788',null);

-- Inserir o mesmo cpf - unique - Este comando dará erro
insert into Funcionario values
    (null, 'Maria Desaparecida','f', 15000, '15915998788', null);
    
insert into Funcionario values
    (null, 'Vitória','f', 50000, '15915915877', 1000);
    
update funcionario set fkSupervisor = 1004 where idFunc = 1000;
    
-- inserção de mais um funcionário (supervisor deste funcionário será a Maria Aparecida - id 1000)    
insert into Funcionario values
	(null, 'José da Silva','m',5000,'12345678999', 1000);
-- inserção de mais um funcionário (supervisor deste funcionário será o José da Silva - id 1001)
insert into Funcionario values
    (null, 'João Oliveira','m', 2000,'65498788844',1001);

-- Exibir os dados dos funcionários e dos supervisores
-- correspondentes
-- se existissem 2 tabelas, uma Funcionario e outra Supervisor, ficaria assim o comando:
-- select * from funcionario join supervisor on fksupervisor = idfunc;
-- mas como a tabela é a mesma, tanto de Funcionario como de Supervisor, então o certo é:
select * from funcionario as func join funcionario as supervisor 
													on func.fksupervisor = supervisor.idfunc;
                                                    
select func.nome as NomeFunc, supervisor.nome as Supervisor 
				from funcionario as func join funcionario as supervisor 
								on func.fksupervisor = supervisor.idfunc;
        
-- Parei aqui!!

-- Criação da tabela Dependente, que é uma entidade fraca em relação a Funcionario 
create table Dependente (
   fkFunc int,
   foreign key (fkFunc) references Funcionario(idFunc),
   idDep int,
   primary key (fkFunc, idDep),  -- chave primária composta
   nomeDep varchar(40),
   dataNasc date,
   parentesco varchar(45)
);
-- Inserção de dependentes
insert into Dependente values
   (1000, 1, 'Ana', '2012-10-01','filha'),
   (1000, 2, 'Paulo', '1984-03-05', 'marido'),
   (1001, 1, 'Antônio', '1968-09-06', 'pai'),
   (1002, 1, 'Clara', '2014-06-01', 'irmã'),
   (1004, 1, 'Vitório', '1994-06-01', 'irmão');
   
insert into Dependente values
   (1002, 2, 'Gema', '2014-06-01', 'irmã');
   
insert into Dependente values
   (1002, 4, 'Casca', '2014-06-01', 'irmã');

select * from funcionario;
-- Exibe a tabela Dependente
select * from Dependente;

-- Exibe os funcionários e seus dependentes
select * from funcionario
inner join dependente on fkFunc = idFunc; 

-- Atualizar os dados de um dependente;
update Dependente set nomeDep='Paulo Jonas' where fkFunc=1000 and idDep = 2;

-- Inserir dados de um funcionário sem supervisor.
insert into Funcionario values
    (null, 'Vivian','f',1100, '12345678779',null);

-- Exibir os dados dos funcionários com e sem dependentes.
select * from funcionario left join dependente on fkFunc = idFunc;

-- Exibir os dados dos funcionários sem dependentes.
select * from funcionario
left join dependente on fkFunc = idFunc
where fkFunc is null;

-- Exibir os dados dos funcionários, seus respectivos supervisores e seus dependentes.
select * from funcionario as f
inner join funcionario as s on s.idFunc = f.fkSupervisor
inner join dependente on fkFunc = f.idFunc;

-- Exibir os dados dos funcionários e seus respectivos supervisores, 
-- funcionários sem supervisor, e seus respectivos dependentes.
select * from funcionario as f
left join funcionario as s on s.idFunc = f.fkSupervisor
inner join dependente on fkFunc = f.idFunc;


-- Criar o banco de dados ac3-seuNome (ac3-vivian);
CREATE DATABASE AC3LUIZHENRIQUE;

-- Selecionar o banco de dados criado;
USE AC3LUIZHENRIQUE;

 -- Criar as tabelas, configurar as chaves estrangeiras e inserir dados;
 CREATE TABLE Login (
idLogin INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45),
email VARCHAR (45),
senha VARCHAR (20)
);

CREATE TABLE Cadastro (
idCadastro INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45),
email VARCHAR (45) UNIQUE,
senha VARCHAR (20),
telefone CHAR (11),
dataNasc DATE,
fkLogin INT,
FOREIGN KEY (fkLogin) REFERENCES Login (idLogin)
);

CREATE TABLE Usuario (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
tipoDiabetes CHAR (1),
fkCadastro INT,
FOREIGN KEY (fkCadastro) REFERENCES Cadastro (idCadastro)
);

CREATE TABLE informacoes (
idInformacaoUsuario INT,
nomeUsuario VARCHAR (45),
emailUsuario VARCHAR (45),
senhaUsuario VARCHAR (20),
fkLogin INT,
FOREIGN KEY (fkLogin) REFERENCES Login (idLogin),
fkUsuario INT, 
FOREIGN KEY (fkUsuario) REFERENCES Usuario (idUsuario),
PRIMARY KEY (fkLogin, fkUsuario)
);

INSERT INTO Login VALUES 
(null, 'Larissa', 'Larissa@gmail.com', 'lari'),
(null, 'Pedro', 'Pedro@gmail.com', 'pedro'),
(null, 'Vivian', 'Vivian@gmail.com', 'vivian'),
(null, 'Julia', 'Julia@gmail.com', 'julia');

INSERT INTO Cadastro VALUES 
(null, 'Larissa', 'Larissa@gmail.com', 'lari','11974385921','2001-06-11',1),
(null, 'Pedro', 'Pedro@gmail.com', 'pedro','11965974592','2012-04-14',2),
(null, 'Vivian', 'Vivian@gmail.com', 'vivian','11957435967','2021-01-03',3),
(null, 'Julia', 'Julia@gmail.com', 'julia','11948349321','2020-10-21',4);

INSERT INTO Usuario VALUES
(null,'1',1),
(null,'2',2),
(null,'3',3),
(null,'4',4);

INSERT INTO Informacoes VALUES 
(1,'Larissa','Larissa@gmail.com','lari',1,1),
(2,'Pedro','Pedro@gmail.com','pedro',2,2),
(3,'Vivian','Vivian@gmail.com','vivian',3,3),
(4,'Julia','Julia@gmail.com','julia',4,4);

-- Exibir os dados das tabelas criadas separadamente;
SELECT * FROM Login;
SELECT * FROM Cadastro;
SELECT * FROM Usuario;
SELECT * FROM informacoes;


Reforço 08/06
    
    create database LuizHenriqueFilme;
use LuizHenriqueFilme;

create table Filmes (
idFilmes int auto_increment,
nomeFilme varchar (45),
genero varchar (45),
fkDiretores int,
primary key (idFilmes, fkDiretores)
)auto_increment=1000;

create table Diretores (
idDiretores int primary key auto_increment,
nomeDiretor varchar (45),
País varchar (45),
dataNasc date
);

create table Atores (
idAtores int primary key,
nomeAtor varchar (45)
)auto_increment=100;


create table Filmes_Atores (
fkFilmes int,
fkAtores int,
nomePersonagem varchar (45),
ganhoAtor float,
primary key (fkFilmes, fkAtores),
foreign key (fkFilmes) references Filmes (idFilmes),
foreign key (fkAtores) references Atores (idAtores)
);

ALTER TABLE Filmes 
ADD foreign key (fkDiretores) references Diretores (idDiretores);

insert into Filmes values 
(null,'Invocação do Mal 3','Terror',1),
(null,'Megatubarão','Suspense',2);

insert into Diretores values 
(null, 'Jason', 'Estados Unidos', 1979-01-14),
(null, 'Gil','Brasil','1890-03-03');


[21:51, 17/06/2021] 𝕷𝖚𝖎𝖟 𝕳𝖊𝖓𝖗𝖎𝖖𝖚𝖊 𝕺𝖑𝖎𝖛𝖊𝖎𝖗𝖆 ♥️: UPDATE nome da tabela SET nome do campo = 'o que você quer mudar' WHERE id da tabela  = número ou campo;
[21:54, 17/06/2021] 𝕷𝖚𝖎𝖟 𝕳𝖊𝖓𝖗𝖎𝖖𝖚𝖊 𝕺𝖑𝖎𝖛𝖊𝖎𝖗𝖆 ♥️: DELETE FROM nome da tabela WHERE Id da tabela = número ou campo;
[22:10, 17/06/2021] 𝕷𝖚𝖎𝖟 𝕳𝖊𝖓𝖗𝖎𝖖𝖚𝖊 𝕺𝖑𝖎𝖛𝖊𝖎𝖗𝖆 ♥️: INNER JOIN:

SELECT * FROM funcionario (nome da tabela) INNER JOIN dependente (nome da tabela secundária) on  fkFunc (exemplo com fk)=  idFunc;
[22:10, 17/06/2021] 𝕷𝖚𝖎𝖟 𝕳𝖊𝖓𝖗𝖎𝖖𝖚𝖊 𝕺𝖑𝖎𝖛𝖊𝖎𝖗𝖆 ♥️: TIPOS DE SELECTS:

Todos os dados de todos os dispositivos do tipo Smartphone em ordem alfabética do modelo:

SELECT * FROM dispositivo (nome da tabela) WHERE tipo (campo da tabela) = smartphone  (atributo da tabela tipo) ORDER BY modelo;

Listar apenas os nomes dos modelos que começam com IP:

SELECT modelo  (campo da tabela) FROM dispositivo ( nome da tabela) WHERE modelo (nome dos modelos) LIKE 'IP%';
[22:12, 17/06/2021] 𝕷𝖚𝖎𝖟 𝕳𝖊𝖓𝖗𝖎𝖖𝖚𝖊 𝕺𝖑𝖎𝖛𝖊𝖎𝖗𝖆 ♥️: INSERT INTO Funcionario (nome da tabela) VALUES 
(null (auto increment), campo1,campo2),
(1, campo1,campo2);
[22:24, 17/06/2021] 𝕷𝖚𝖎𝖟 𝕳𝖊𝖓𝖗𝖎𝖖𝖚𝖊 𝕺𝖑𝖎𝖛𝖊𝖎𝖗𝖆 ♥️: CRIAÇÃO DAS TABELAS COM FOREIGN KEYS:

CREATE TABLE Login (
idLogin INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45),
email VARCHAR (45),
senha VARCHAR (20)
); 

CREATE TABLE Cadastro (
idCadastro INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR (45),
email VARCHAR (45) UNIQUE,
senha VARCHAR (20),
telefone CHAR (11),
dataNasc DATE,
fkLogin INT,
FOREIGN KEY (fkLogin) REFERENCES Login (idLogin)
);

CREATE TABLE Usuario (
idUsuario INT PRIMARY KEY AUTO_INCREMENT,
tipoDiabetes CHAR (1),
fkCadastro INT,
FOREIGN KEY (fkCadastro) REFERENCES Cadastro (idCadastro)
);

CREATE TABLE informacoes (
idInformacaoUsuario INT,
nomeUsuario VARCHAR (45),
emailUsuario VARCHAR (45),
senhaUsuario VARCHAR (20),
fkLogin INT,
FOREIGN KEY (fkLogin) REFERENCES Login (idLogin),
fkUsuario …
[22:25, 17/06/2021] 𝕷𝖚𝖎𝖟 𝕳𝖊𝖓𝖗𝖎𝖖𝖚𝖊 𝕺𝖑𝖎𝖛𝖊𝖎𝖗𝖆 ♥️: ALTER TABLE Empresa MODIFY nomeEmpresa varchar(40);

ALTER TABLE NomeDaTabela MODIFY NomeDoCampo TipoDoCampo;

Exemplo: ALTER TABLE empresa MODIFY NomeEmpresa VARCHAR(50);
